{"ast":null,"code":"// Generated by CoffeeScript 1.12.7\n(function () {\n  var BOM,\n    BOOL,\n    CALLABLE,\n    CODE,\n    COFFEE_ALIASES,\n    COFFEE_ALIAS_MAP,\n    COFFEE_KEYWORDS,\n    COMMENT,\n    COMPARE,\n    COMPOUND_ASSIGN,\n    HERECOMMENT_ILLEGAL,\n    HEREDOC_DOUBLE,\n    HEREDOC_INDENT,\n    HEREDOC_SINGLE,\n    HEREGEX,\n    HEREGEX_OMIT,\n    HERE_JSTOKEN,\n    IDENTIFIER,\n    INDENTABLE_CLOSERS,\n    INDEXABLE,\n    INVERSES,\n    JSTOKEN,\n    JS_KEYWORDS,\n    LEADING_BLANK_LINE,\n    LINE_BREAK,\n    LINE_CONTINUER,\n    Lexer,\n    MATH,\n    MULTI_DENT,\n    NOT_REGEX,\n    NUMBER,\n    OPERATOR,\n    POSSIBLY_DIVISION,\n    REGEX,\n    REGEX_FLAGS,\n    REGEX_ILLEGAL,\n    REGEX_INVALID_ESCAPE,\n    RELATION,\n    RESERVED,\n    Rewriter,\n    SHIFT,\n    SIMPLE_STRING_OMIT,\n    STRICT_PROSCRIBED,\n    STRING_DOUBLE,\n    STRING_INVALID_ESCAPE,\n    STRING_OMIT,\n    STRING_SINGLE,\n    STRING_START,\n    TRAILING_BLANK_LINE,\n    TRAILING_SPACES,\n    UNARY,\n    UNARY_MATH,\n    UNFINISHED,\n    UNICODE_CODE_POINT_ESCAPE,\n    VALID_FLAGS,\n    WHITESPACE,\n    compact,\n    count,\n    invertLiterate,\n    isForFrom,\n    isUnassignable,\n    key,\n    locationDataToString,\n    ref,\n    ref1,\n    repeat,\n    starts,\n    throwSyntaxError,\n    indexOf = [].indexOf || function (item) {\n      for (var i = 0, l = this.length; i < l; i++) {\n        if (i in this && this[i] === item) return i;\n      }\n      return -1;\n    },\n    slice = [].slice;\n  ref = require('./rewriter'), Rewriter = ref.Rewriter, INVERSES = ref.INVERSES;\n  ref1 = require('./helpers'), count = ref1.count, starts = ref1.starts, compact = ref1.compact, repeat = ref1.repeat, invertLiterate = ref1.invertLiterate, locationDataToString = ref1.locationDataToString, throwSyntaxError = ref1.throwSyntaxError;\n  exports.Lexer = Lexer = function () {\n    function Lexer() {}\n    Lexer.prototype.tokenize = function (code, opts) {\n      var consumed, end, i, ref2;\n      if (opts == null) {\n        opts = {};\n      }\n      this.literate = opts.literate;\n      this.indent = 0;\n      this.baseIndent = 0;\n      this.indebt = 0;\n      this.outdebt = 0;\n      this.indents = [];\n      this.ends = [];\n      this.tokens = [];\n      this.seenFor = false;\n      this.seenImport = false;\n      this.seenExport = false;\n      this.importSpecifierList = false;\n      this.exportSpecifierList = false;\n      this.chunkLine = opts.line || 0;\n      this.chunkColumn = opts.column || 0;\n      code = this.clean(code);\n      i = 0;\n      while (this.chunk = code.slice(i)) {\n        consumed = this.identifierToken() || this.commentToken() || this.whitespaceToken() || this.lineToken() || this.stringToken() || this.numberToken() || this.regexToken() || this.jsToken() || this.literalToken();\n        ref2 = this.getLineAndColumnFromChunk(consumed), this.chunkLine = ref2[0], this.chunkColumn = ref2[1];\n        i += consumed;\n        if (opts.untilBalanced && this.ends.length === 0) {\n          return {\n            tokens: this.tokens,\n            index: i\n          };\n        }\n      }\n      this.closeIndentation();\n      if (end = this.ends.pop()) {\n        this.error(\"missing \" + end.tag, end.origin[2]);\n      }\n      if (opts.rewrite === false) {\n        return this.tokens;\n      }\n      return new Rewriter().rewrite(this.tokens);\n    };\n    Lexer.prototype.clean = function (code) {\n      if (code.charCodeAt(0) === BOM) {\n        code = code.slice(1);\n      }\n      code = code.replace(/\\r/g, '').replace(TRAILING_SPACES, '');\n      if (WHITESPACE.test(code)) {\n        code = \"\\n\" + code;\n        this.chunkLine--;\n      }\n      if (this.literate) {\n        code = invertLiterate(code);\n      }\n      return code;\n    };\n    Lexer.prototype.identifierToken = function () {\n      var alias, colon, colonOffset, id, idLength, input, match, poppedToken, prev, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, tag, tagToken;\n      if (!(match = IDENTIFIER.exec(this.chunk))) {\n        return 0;\n      }\n      input = match[0], id = match[1], colon = match[2];\n      idLength = id.length;\n      poppedToken = void 0;\n      if (id === 'own' && this.tag() === 'FOR') {\n        this.token('OWN', id);\n        return id.length;\n      }\n      if (id === 'from' && this.tag() === 'YIELD') {\n        this.token('FROM', id);\n        return id.length;\n      }\n      if (id === 'as' && this.seenImport) {\n        if (this.value() === '*') {\n          this.tokens[this.tokens.length - 1][0] = 'IMPORT_ALL';\n        } else if (ref2 = this.value(), indexOf.call(COFFEE_KEYWORDS, ref2) >= 0) {\n          this.tokens[this.tokens.length - 1][0] = 'IDENTIFIER';\n        }\n        if ((ref3 = this.tag()) === 'DEFAULT' || ref3 === 'IMPORT_ALL' || ref3 === 'IDENTIFIER') {\n          this.token('AS', id);\n          return id.length;\n        }\n      }\n      if (id === 'as' && this.seenExport && ((ref4 = this.tag()) === 'IDENTIFIER' || ref4 === 'DEFAULT')) {\n        this.token('AS', id);\n        return id.length;\n      }\n      if (id === 'default' && this.seenExport && ((ref5 = this.tag()) === 'EXPORT' || ref5 === 'AS')) {\n        this.token('DEFAULT', id);\n        return id.length;\n      }\n      ref6 = this.tokens, prev = ref6[ref6.length - 1];\n      tag = colon || prev != null && ((ref7 = prev[0]) === '.' || ref7 === '?.' || ref7 === '::' || ref7 === '?::' || !prev.spaced && prev[0] === '@') ? 'PROPERTY' : 'IDENTIFIER';\n      if (tag === 'IDENTIFIER' && (indexOf.call(JS_KEYWORDS, id) >= 0 || indexOf.call(COFFEE_KEYWORDS, id) >= 0) && !(this.exportSpecifierList && indexOf.call(COFFEE_KEYWORDS, id) >= 0)) {\n        tag = id.toUpperCase();\n        if (tag === 'WHEN' && (ref8 = this.tag(), indexOf.call(LINE_BREAK, ref8) >= 0)) {\n          tag = 'LEADING_WHEN';\n        } else if (tag === 'FOR') {\n          this.seenFor = true;\n        } else if (tag === 'UNLESS') {\n          tag = 'IF';\n        } else if (tag === 'IMPORT') {\n          this.seenImport = true;\n        } else if (tag === 'EXPORT') {\n          this.seenExport = true;\n        } else if (indexOf.call(UNARY, tag) >= 0) {\n          tag = 'UNARY';\n        } else if (indexOf.call(RELATION, tag) >= 0) {\n          if (tag !== 'INSTANCEOF' && this.seenFor) {\n            tag = 'FOR' + tag;\n            this.seenFor = false;\n          } else {\n            tag = 'RELATION';\n            if (this.value() === '!') {\n              poppedToken = this.tokens.pop();\n              id = '!' + id;\n            }\n          }\n        }\n      } else if (tag === 'IDENTIFIER' && this.seenFor && id === 'from' && isForFrom(prev)) {\n        tag = 'FORFROM';\n        this.seenFor = false;\n      }\n      if (tag === 'IDENTIFIER' && indexOf.call(RESERVED, id) >= 0) {\n        this.error(\"reserved word '\" + id + \"'\", {\n          length: id.length\n        });\n      }\n      if (tag !== 'PROPERTY') {\n        if (indexOf.call(COFFEE_ALIASES, id) >= 0) {\n          alias = id;\n          id = COFFEE_ALIAS_MAP[id];\n        }\n        tag = function () {\n          switch (id) {\n            case '!':\n              return 'UNARY';\n            case '==':\n            case '!=':\n              return 'COMPARE';\n            case 'true':\n            case 'false':\n              return 'BOOL';\n            case 'break':\n            case 'continue':\n            case 'debugger':\n              return 'STATEMENT';\n            case '&&':\n            case '||':\n              return id;\n            default:\n              return tag;\n          }\n        }();\n      }\n      tagToken = this.token(tag, id, 0, idLength);\n      if (alias) {\n        tagToken.origin = [tag, alias, tagToken[2]];\n      }\n      if (poppedToken) {\n        ref9 = [poppedToken[2].first_line, poppedToken[2].first_column], tagToken[2].first_line = ref9[0], tagToken[2].first_column = ref9[1];\n      }\n      if (colon) {\n        colonOffset = input.lastIndexOf(':');\n        this.token(':', ':', colonOffset, colon.length);\n      }\n      return input.length;\n    };\n    Lexer.prototype.numberToken = function () {\n      var base, lexedLength, match, number, numberValue, ref2, tag;\n      if (!(match = NUMBER.exec(this.chunk))) {\n        return 0;\n      }\n      number = match[0];\n      lexedLength = number.length;\n      switch (false) {\n        case !/^0[BOX]/.test(number):\n          this.error(\"radix prefix in '\" + number + \"' must be lowercase\", {\n            offset: 1\n          });\n          break;\n        case !/^(?!0x).*E/.test(number):\n          this.error(\"exponential notation in '\" + number + \"' must be indicated with a lowercase 'e'\", {\n            offset: number.indexOf('E')\n          });\n          break;\n        case !/^0\\d*[89]/.test(number):\n          this.error(\"decimal literal '\" + number + \"' must not be prefixed with '0'\", {\n            length: lexedLength\n          });\n          break;\n        case !/^0\\d+/.test(number):\n          this.error(\"octal literal '\" + number + \"' must be prefixed with '0o'\", {\n            length: lexedLength\n          });\n      }\n      base = function () {\n        switch (number.charAt(1)) {\n          case 'b':\n            return 2;\n          case 'o':\n            return 8;\n          case 'x':\n            return 16;\n          default:\n            return null;\n        }\n      }();\n      numberValue = base != null ? parseInt(number.slice(2), base) : parseFloat(number);\n      if ((ref2 = number.charAt(1)) === 'b' || ref2 === 'o') {\n        number = \"0x\" + numberValue.toString(16);\n      }\n      tag = numberValue === 2e308 ? 'INFINITY' : 'NUMBER';\n      this.token(tag, number, 0, lexedLength);\n      return lexedLength;\n    };\n    Lexer.prototype.stringToken = function () {\n      var $, attempt, delimiter, doc, end, heredoc, i, indent, indentRegex, match, quote, ref2, ref3, regex, token, tokens;\n      quote = (STRING_START.exec(this.chunk) || [])[0];\n      if (!quote) {\n        return 0;\n      }\n      if (this.tokens.length && this.value() === 'from' && (this.seenImport || this.seenExport)) {\n        this.tokens[this.tokens.length - 1][0] = 'FROM';\n      }\n      regex = function () {\n        switch (quote) {\n          case \"'\":\n            return STRING_SINGLE;\n          case '\"':\n            return STRING_DOUBLE;\n          case \"'''\":\n            return HEREDOC_SINGLE;\n          case '\"\"\"':\n            return HEREDOC_DOUBLE;\n        }\n      }();\n      heredoc = quote.length === 3;\n      ref2 = this.matchWithInterpolations(regex, quote), tokens = ref2.tokens, end = ref2.index;\n      $ = tokens.length - 1;\n      delimiter = quote.charAt(0);\n      if (heredoc) {\n        indent = null;\n        doc = function () {\n          var j, len, results;\n          results = [];\n          for (i = j = 0, len = tokens.length; j < len; i = ++j) {\n            token = tokens[i];\n            if (token[0] === 'NEOSTRING') {\n              results.push(token[1]);\n            }\n          }\n          return results;\n        }().join('#{}');\n        while (match = HEREDOC_INDENT.exec(doc)) {\n          attempt = match[1];\n          if (indent === null || 0 < (ref3 = attempt.length) && ref3 < indent.length) {\n            indent = attempt;\n          }\n        }\n        if (indent) {\n          indentRegex = RegExp(\"\\\\n\" + indent, \"g\");\n        }\n        this.mergeInterpolationTokens(tokens, {\n          delimiter: delimiter\n        }, function (_this) {\n          return function (value, i) {\n            value = _this.formatString(value, {\n              delimiter: quote\n            });\n            if (indentRegex) {\n              value = value.replace(indentRegex, '\\n');\n            }\n            if (i === 0) {\n              value = value.replace(LEADING_BLANK_LINE, '');\n            }\n            if (i === $) {\n              value = value.replace(TRAILING_BLANK_LINE, '');\n            }\n            return value;\n          };\n        }(this));\n      } else {\n        this.mergeInterpolationTokens(tokens, {\n          delimiter: delimiter\n        }, function (_this) {\n          return function (value, i) {\n            value = _this.formatString(value, {\n              delimiter: quote\n            });\n            value = value.replace(SIMPLE_STRING_OMIT, function (match, offset) {\n              if (i === 0 && offset === 0 || i === $ && offset + match.length === value.length) {\n                return '';\n              } else {\n                return ' ';\n              }\n            });\n            return value;\n          };\n        }(this));\n      }\n      return end;\n    };\n    Lexer.prototype.commentToken = function () {\n      var comment, here, match;\n      if (!(match = this.chunk.match(COMMENT))) {\n        return 0;\n      }\n      comment = match[0], here = match[1];\n      if (here) {\n        if (match = HERECOMMENT_ILLEGAL.exec(comment)) {\n          this.error(\"block comments cannot contain \" + match[0], {\n            offset: match.index,\n            length: match[0].length\n          });\n        }\n        if (here.indexOf('\\n') >= 0) {\n          here = here.replace(RegExp(\"\\\\n\" + repeat(' ', this.indent), \"g\"), '\\n');\n        }\n        this.token('HERECOMMENT', here, 0, comment.length);\n      }\n      return comment.length;\n    };\n    Lexer.prototype.jsToken = function () {\n      var match, script;\n      if (!(this.chunk.charAt(0) === '`' && (match = HERE_JSTOKEN.exec(this.chunk) || JSTOKEN.exec(this.chunk)))) {\n        return 0;\n      }\n      script = match[1].replace(/\\\\+(`|$)/g, function (string) {\n        return string.slice(-Math.ceil(string.length / 2));\n      });\n      this.token('JS', script, 0, match[0].length);\n      return match[0].length;\n    };\n    Lexer.prototype.regexToken = function () {\n      var body, closed, end, flags, index, match, origin, prev, ref2, ref3, ref4, regex, tokens;\n      switch (false) {\n        case !(match = REGEX_ILLEGAL.exec(this.chunk)):\n          this.error(\"regular expressions cannot begin with \" + match[2], {\n            offset: match.index + match[1].length\n          });\n          break;\n        case !(match = this.matchWithInterpolations(HEREGEX, '///')):\n          tokens = match.tokens, index = match.index;\n          break;\n        case !(match = REGEX.exec(this.chunk)):\n          regex = match[0], body = match[1], closed = match[2];\n          this.validateEscapes(body, {\n            isRegex: true,\n            offsetInChunk: 1\n          });\n          body = this.formatRegex(body, {\n            delimiter: '/'\n          });\n          index = regex.length;\n          ref2 = this.tokens, prev = ref2[ref2.length - 1];\n          if (prev) {\n            if (prev.spaced && (ref3 = prev[0], indexOf.call(CALLABLE, ref3) >= 0)) {\n              if (!closed || POSSIBLY_DIVISION.test(regex)) {\n                return 0;\n              }\n            } else if (ref4 = prev[0], indexOf.call(NOT_REGEX, ref4) >= 0) {\n              return 0;\n            }\n          }\n          if (!closed) {\n            this.error('missing / (unclosed regex)');\n          }\n          break;\n        default:\n          return 0;\n      }\n      flags = REGEX_FLAGS.exec(this.chunk.slice(index))[0];\n      end = index + flags.length;\n      origin = this.makeToken('REGEX', null, 0, end);\n      switch (false) {\n        case !!VALID_FLAGS.test(flags):\n          this.error(\"invalid regular expression flags \" + flags, {\n            offset: index,\n            length: flags.length\n          });\n          break;\n        case !(regex || tokens.length === 1):\n          if (body == null) {\n            body = this.formatHeregex(tokens[0][1]);\n          }\n          this.token('REGEX', \"\" + this.makeDelimitedLiteral(body, {\n            delimiter: '/'\n          }) + flags, 0, end, origin);\n          break;\n        default:\n          this.token('REGEX_START', '(', 0, 0, origin);\n          this.token('IDENTIFIER', 'RegExp', 0, 0);\n          this.token('CALL_START', '(', 0, 0);\n          this.mergeInterpolationTokens(tokens, {\n            delimiter: '\"',\n            double: true\n          }, this.formatHeregex);\n          if (flags) {\n            this.token(',', ',', index - 1, 0);\n            this.token('STRING', '\"' + flags + '\"', index - 1, flags.length);\n          }\n          this.token(')', ')', end - 1, 0);\n          this.token('REGEX_END', ')', end - 1, 0);\n      }\n      return end;\n    };\n    Lexer.prototype.lineToken = function () {\n      var diff, indent, match, noNewlines, size;\n      if (!(match = MULTI_DENT.exec(this.chunk))) {\n        return 0;\n      }\n      indent = match[0];\n      this.seenFor = false;\n      if (!this.importSpecifierList) {\n        this.seenImport = false;\n      }\n      if (!this.exportSpecifierList) {\n        this.seenExport = false;\n      }\n      size = indent.length - 1 - indent.lastIndexOf('\\n');\n      noNewlines = this.unfinished();\n      if (size - this.indebt === this.indent) {\n        if (noNewlines) {\n          this.suppressNewlines();\n        } else {\n          this.newlineToken(0);\n        }\n        return indent.length;\n      }\n      if (size > this.indent) {\n        if (noNewlines) {\n          this.indebt = size - this.indent;\n          this.suppressNewlines();\n          return indent.length;\n        }\n        if (!this.tokens.length) {\n          this.baseIndent = this.indent = size;\n          return indent.length;\n        }\n        diff = size - this.indent + this.outdebt;\n        this.token('INDENT', diff, indent.length - size, size);\n        this.indents.push(diff);\n        this.ends.push({\n          tag: 'OUTDENT'\n        });\n        this.outdebt = this.indebt = 0;\n        this.indent = size;\n      } else if (size < this.baseIndent) {\n        this.error('missing indentation', {\n          offset: indent.length\n        });\n      } else {\n        this.indebt = 0;\n        this.outdentToken(this.indent - size, noNewlines, indent.length);\n      }\n      return indent.length;\n    };\n    Lexer.prototype.outdentToken = function (moveOut, noNewlines, outdentLength) {\n      var decreasedIndent, dent, lastIndent, ref2;\n      decreasedIndent = this.indent - moveOut;\n      while (moveOut > 0) {\n        lastIndent = this.indents[this.indents.length - 1];\n        if (!lastIndent) {\n          moveOut = 0;\n        } else if (lastIndent === this.outdebt) {\n          moveOut -= this.outdebt;\n          this.outdebt = 0;\n        } else if (lastIndent < this.outdebt) {\n          this.outdebt -= lastIndent;\n          moveOut -= lastIndent;\n        } else {\n          dent = this.indents.pop() + this.outdebt;\n          if (outdentLength && (ref2 = this.chunk[outdentLength], indexOf.call(INDENTABLE_CLOSERS, ref2) >= 0)) {\n            decreasedIndent -= dent - moveOut;\n            moveOut = dent;\n          }\n          this.outdebt = 0;\n          this.pair('OUTDENT');\n          this.token('OUTDENT', moveOut, 0, outdentLength);\n          moveOut -= dent;\n        }\n      }\n      if (dent) {\n        this.outdebt -= moveOut;\n      }\n      while (this.value() === ';') {\n        this.tokens.pop();\n      }\n      if (!(this.tag() === 'TERMINATOR' || noNewlines)) {\n        this.token('TERMINATOR', '\\n', outdentLength, 0);\n      }\n      this.indent = decreasedIndent;\n      return this;\n    };\n    Lexer.prototype.whitespaceToken = function () {\n      var match, nline, prev, ref2;\n      if (!((match = WHITESPACE.exec(this.chunk)) || (nline = this.chunk.charAt(0) === '\\n'))) {\n        return 0;\n      }\n      ref2 = this.tokens, prev = ref2[ref2.length - 1];\n      if (prev) {\n        prev[match ? 'spaced' : 'newLine'] = true;\n      }\n      if (match) {\n        return match[0].length;\n      } else {\n        return 0;\n      }\n    };\n    Lexer.prototype.newlineToken = function (offset) {\n      while (this.value() === ';') {\n        this.tokens.pop();\n      }\n      if (this.tag() !== 'TERMINATOR') {\n        this.token('TERMINATOR', '\\n', offset, 0);\n      }\n      return this;\n    };\n    Lexer.prototype.suppressNewlines = function () {\n      if (this.value() === '\\\\') {\n        this.tokens.pop();\n      }\n      return this;\n    };\n    Lexer.prototype.literalToken = function () {\n      var match, message, origin, prev, ref2, ref3, ref4, ref5, ref6, skipToken, tag, token, value;\n      if (match = OPERATOR.exec(this.chunk)) {\n        value = match[0];\n        if (CODE.test(value)) {\n          this.tagParameters();\n        }\n      } else {\n        value = this.chunk.charAt(0);\n      }\n      tag = value;\n      ref2 = this.tokens, prev = ref2[ref2.length - 1];\n      if (prev && indexOf.call(['='].concat(slice.call(COMPOUND_ASSIGN)), value) >= 0) {\n        skipToken = false;\n        if (value === '=' && ((ref3 = prev[1]) === '||' || ref3 === '&&') && !prev.spaced) {\n          prev[0] = 'COMPOUND_ASSIGN';\n          prev[1] += '=';\n          prev = this.tokens[this.tokens.length - 2];\n          skipToken = true;\n        }\n        if (prev && prev[0] !== 'PROPERTY') {\n          origin = (ref4 = prev.origin) != null ? ref4 : prev;\n          message = isUnassignable(prev[1], origin[1]);\n          if (message) {\n            this.error(message, origin[2]);\n          }\n        }\n        if (skipToken) {\n          return value.length;\n        }\n      }\n      if (value === '{' && this.seenImport) {\n        this.importSpecifierList = true;\n      } else if (this.importSpecifierList && value === '}') {\n        this.importSpecifierList = false;\n      } else if (value === '{' && (prev != null ? prev[0] : void 0) === 'EXPORT') {\n        this.exportSpecifierList = true;\n      } else if (this.exportSpecifierList && value === '}') {\n        this.exportSpecifierList = false;\n      }\n      if (value === ';') {\n        this.seenFor = this.seenImport = this.seenExport = false;\n        tag = 'TERMINATOR';\n      } else if (value === '*' && prev[0] === 'EXPORT') {\n        tag = 'EXPORT_ALL';\n      } else if (indexOf.call(MATH, value) >= 0) {\n        tag = 'MATH';\n      } else if (indexOf.call(COMPARE, value) >= 0) {\n        tag = 'COMPARE';\n      } else if (indexOf.call(COMPOUND_ASSIGN, value) >= 0) {\n        tag = 'COMPOUND_ASSIGN';\n      } else if (indexOf.call(UNARY, value) >= 0) {\n        tag = 'UNARY';\n      } else if (indexOf.call(UNARY_MATH, value) >= 0) {\n        tag = 'UNARY_MATH';\n      } else if (indexOf.call(SHIFT, value) >= 0) {\n        tag = 'SHIFT';\n      } else if (value === '?' && (prev != null ? prev.spaced : void 0)) {\n        tag = 'BIN?';\n      } else if (prev && !prev.spaced) {\n        if (value === '(' && (ref5 = prev[0], indexOf.call(CALLABLE, ref5) >= 0)) {\n          if (prev[0] === '?') {\n            prev[0] = 'FUNC_EXIST';\n          }\n          tag = 'CALL_START';\n        } else if (value === '[' && (ref6 = prev[0], indexOf.call(INDEXABLE, ref6) >= 0)) {\n          tag = 'INDEX_START';\n          switch (prev[0]) {\n            case '?':\n              prev[0] = 'INDEX_SOAK';\n          }\n        }\n      }\n      token = this.makeToken(tag, value);\n      switch (value) {\n        case '(':\n        case '{':\n        case '[':\n          this.ends.push({\n            tag: INVERSES[value],\n            origin: token\n          });\n          break;\n        case ')':\n        case '}':\n        case ']':\n          this.pair(value);\n      }\n      this.tokens.push(token);\n      return value.length;\n    };\n    Lexer.prototype.tagParameters = function () {\n      var i, stack, tok, tokens;\n      if (this.tag() !== ')') {\n        return this;\n      }\n      stack = [];\n      tokens = this.tokens;\n      i = tokens.length;\n      tokens[--i][0] = 'PARAM_END';\n      while (tok = tokens[--i]) {\n        switch (tok[0]) {\n          case ')':\n            stack.push(tok);\n            break;\n          case '(':\n          case 'CALL_START':\n            if (stack.length) {\n              stack.pop();\n            } else if (tok[0] === '(') {\n              tok[0] = 'PARAM_START';\n              return this;\n            } else {\n              return this;\n            }\n        }\n      }\n      return this;\n    };\n    Lexer.prototype.closeIndentation = function () {\n      return this.outdentToken(this.indent);\n    };\n    Lexer.prototype.matchWithInterpolations = function (regex, delimiter) {\n      var close, column, firstToken, index, lastToken, line, nested, offsetInChunk, open, ref2, ref3, ref4, str, strPart, tokens;\n      tokens = [];\n      offsetInChunk = delimiter.length;\n      if (this.chunk.slice(0, offsetInChunk) !== delimiter) {\n        return null;\n      }\n      str = this.chunk.slice(offsetInChunk);\n      while (true) {\n        strPart = regex.exec(str)[0];\n        this.validateEscapes(strPart, {\n          isRegex: delimiter.charAt(0) === '/',\n          offsetInChunk: offsetInChunk\n        });\n        tokens.push(this.makeToken('NEOSTRING', strPart, offsetInChunk));\n        str = str.slice(strPart.length);\n        offsetInChunk += strPart.length;\n        if (str.slice(0, 2) !== '#{') {\n          break;\n        }\n        ref2 = this.getLineAndColumnFromChunk(offsetInChunk + 1), line = ref2[0], column = ref2[1];\n        ref3 = new Lexer().tokenize(str.slice(1), {\n          line: line,\n          column: column,\n          untilBalanced: true\n        }), nested = ref3.tokens, index = ref3.index;\n        index += 1;\n        open = nested[0], close = nested[nested.length - 1];\n        open[0] = open[1] = '(';\n        close[0] = close[1] = ')';\n        close.origin = ['', 'end of interpolation', close[2]];\n        if (((ref4 = nested[1]) != null ? ref4[0] : void 0) === 'TERMINATOR') {\n          nested.splice(1, 1);\n        }\n        tokens.push(['TOKENS', nested]);\n        str = str.slice(index);\n        offsetInChunk += index;\n      }\n      if (str.slice(0, delimiter.length) !== delimiter) {\n        this.error(\"missing \" + delimiter, {\n          length: delimiter.length\n        });\n      }\n      firstToken = tokens[0], lastToken = tokens[tokens.length - 1];\n      firstToken[2].first_column -= delimiter.length;\n      if (lastToken[1].substr(-1) === '\\n') {\n        lastToken[2].last_line += 1;\n        lastToken[2].last_column = delimiter.length - 1;\n      } else {\n        lastToken[2].last_column += delimiter.length;\n      }\n      if (lastToken[1].length === 0) {\n        lastToken[2].last_column -= 1;\n      }\n      return {\n        tokens: tokens,\n        index: offsetInChunk + delimiter.length\n      };\n    };\n    Lexer.prototype.mergeInterpolationTokens = function (tokens, options, fn) {\n      var converted, firstEmptyStringIndex, firstIndex, i, j, lastToken, len, locationToken, lparen, plusToken, ref2, rparen, tag, token, tokensToPush, value;\n      if (tokens.length > 1) {\n        lparen = this.token('STRING_START', '(', 0, 0);\n      }\n      firstIndex = this.tokens.length;\n      for (i = j = 0, len = tokens.length; j < len; i = ++j) {\n        token = tokens[i];\n        tag = token[0], value = token[1];\n        switch (tag) {\n          case 'TOKENS':\n            if (value.length === 2) {\n              continue;\n            }\n            locationToken = value[0];\n            tokensToPush = value;\n            break;\n          case 'NEOSTRING':\n            converted = fn.call(this, token[1], i);\n            if (converted.length === 0) {\n              if (i === 0) {\n                firstEmptyStringIndex = this.tokens.length;\n              } else {\n                continue;\n              }\n            }\n            if (i === 2 && firstEmptyStringIndex != null) {\n              this.tokens.splice(firstEmptyStringIndex, 2);\n            }\n            token[0] = 'STRING';\n            token[1] = this.makeDelimitedLiteral(converted, options);\n            locationToken = token;\n            tokensToPush = [token];\n        }\n        if (this.tokens.length > firstIndex) {\n          plusToken = this.token('+', '+');\n          plusToken[2] = {\n            first_line: locationToken[2].first_line,\n            first_column: locationToken[2].first_column,\n            last_line: locationToken[2].first_line,\n            last_column: locationToken[2].first_column\n          };\n        }\n        (ref2 = this.tokens).push.apply(ref2, tokensToPush);\n      }\n      if (lparen) {\n        lastToken = tokens[tokens.length - 1];\n        lparen.origin = ['STRING', null, {\n          first_line: lparen[2].first_line,\n          first_column: lparen[2].first_column,\n          last_line: lastToken[2].last_line,\n          last_column: lastToken[2].last_column\n        }];\n        rparen = this.token('STRING_END', ')');\n        return rparen[2] = {\n          first_line: lastToken[2].last_line,\n          first_column: lastToken[2].last_column,\n          last_line: lastToken[2].last_line,\n          last_column: lastToken[2].last_column\n        };\n      }\n    };\n    Lexer.prototype.pair = function (tag) {\n      var lastIndent, prev, ref2, ref3, wanted;\n      ref2 = this.ends, prev = ref2[ref2.length - 1];\n      if (tag !== (wanted = prev != null ? prev.tag : void 0)) {\n        if ('OUTDENT' !== wanted) {\n          this.error(\"unmatched \" + tag);\n        }\n        ref3 = this.indents, lastIndent = ref3[ref3.length - 1];\n        this.outdentToken(lastIndent, true);\n        return this.pair(tag);\n      }\n      return this.ends.pop();\n    };\n    Lexer.prototype.getLineAndColumnFromChunk = function (offset) {\n      var column, lastLine, lineCount, ref2, string;\n      if (offset === 0) {\n        return [this.chunkLine, this.chunkColumn];\n      }\n      if (offset >= this.chunk.length) {\n        string = this.chunk;\n      } else {\n        string = this.chunk.slice(0, +(offset - 1) + 1 || 9e9);\n      }\n      lineCount = count(string, '\\n');\n      column = this.chunkColumn;\n      if (lineCount > 0) {\n        ref2 = string.split('\\n'), lastLine = ref2[ref2.length - 1];\n        column = lastLine.length;\n      } else {\n        column += string.length;\n      }\n      return [this.chunkLine + lineCount, column];\n    };\n    Lexer.prototype.makeToken = function (tag, value, offsetInChunk, length) {\n      var lastCharacter, locationData, ref2, ref3, token;\n      if (offsetInChunk == null) {\n        offsetInChunk = 0;\n      }\n      if (length == null) {\n        length = value.length;\n      }\n      locationData = {};\n      ref2 = this.getLineAndColumnFromChunk(offsetInChunk), locationData.first_line = ref2[0], locationData.first_column = ref2[1];\n      lastCharacter = length > 0 ? length - 1 : 0;\n      ref3 = this.getLineAndColumnFromChunk(offsetInChunk + lastCharacter), locationData.last_line = ref3[0], locationData.last_column = ref3[1];\n      token = [tag, value, locationData];\n      return token;\n    };\n    Lexer.prototype.token = function (tag, value, offsetInChunk, length, origin) {\n      var token;\n      token = this.makeToken(tag, value, offsetInChunk, length);\n      if (origin) {\n        token.origin = origin;\n      }\n      this.tokens.push(token);\n      return token;\n    };\n    Lexer.prototype.tag = function () {\n      var ref2, token;\n      ref2 = this.tokens, token = ref2[ref2.length - 1];\n      return token != null ? token[0] : void 0;\n    };\n    Lexer.prototype.value = function () {\n      var ref2, token;\n      ref2 = this.tokens, token = ref2[ref2.length - 1];\n      return token != null ? token[1] : void 0;\n    };\n    Lexer.prototype.unfinished = function () {\n      var ref2;\n      return LINE_CONTINUER.test(this.chunk) || (ref2 = this.tag(), indexOf.call(UNFINISHED, ref2) >= 0);\n    };\n    Lexer.prototype.formatString = function (str, options) {\n      return this.replaceUnicodeCodePointEscapes(str.replace(STRING_OMIT, '$1'), options);\n    };\n    Lexer.prototype.formatHeregex = function (str) {\n      return this.formatRegex(str.replace(HEREGEX_OMIT, '$1$2'), {\n        delimiter: '///'\n      });\n    };\n    Lexer.prototype.formatRegex = function (str, options) {\n      return this.replaceUnicodeCodePointEscapes(str, options);\n    };\n    Lexer.prototype.unicodeCodePointToUnicodeEscapes = function (codePoint) {\n      var high, low, toUnicodeEscape;\n      toUnicodeEscape = function (val) {\n        var str;\n        str = val.toString(16);\n        return \"\\\\u\" + repeat('0', 4 - str.length) + str;\n      };\n      if (codePoint < 0x10000) {\n        return toUnicodeEscape(codePoint);\n      }\n      high = Math.floor((codePoint - 0x10000) / 0x400) + 0xD800;\n      low = (codePoint - 0x10000) % 0x400 + 0xDC00;\n      return \"\" + toUnicodeEscape(high) + toUnicodeEscape(low);\n    };\n    Lexer.prototype.replaceUnicodeCodePointEscapes = function (str, options) {\n      return str.replace(UNICODE_CODE_POINT_ESCAPE, function (_this) {\n        return function (match, escapedBackslash, codePointHex, offset) {\n          var codePointDecimal;\n          if (escapedBackslash) {\n            return escapedBackslash;\n          }\n          codePointDecimal = parseInt(codePointHex, 16);\n          if (codePointDecimal > 0x10ffff) {\n            _this.error(\"unicode code point escapes greater than \\\\u{10ffff} are not allowed\", {\n              offset: offset + options.delimiter.length,\n              length: codePointHex.length + 4\n            });\n          }\n          return _this.unicodeCodePointToUnicodeEscapes(codePointDecimal);\n        };\n      }(this));\n    };\n    Lexer.prototype.validateEscapes = function (str, options) {\n      var before, hex, invalidEscape, invalidEscapeRegex, match, message, octal, ref2, unicode, unicodeCodePoint;\n      if (options == null) {\n        options = {};\n      }\n      invalidEscapeRegex = options.isRegex ? REGEX_INVALID_ESCAPE : STRING_INVALID_ESCAPE;\n      match = invalidEscapeRegex.exec(str);\n      if (!match) {\n        return;\n      }\n      match[0], before = match[1], octal = match[2], hex = match[3], unicodeCodePoint = match[4], unicode = match[5];\n      message = octal ? \"octal escape sequences are not allowed\" : \"invalid escape sequence\";\n      invalidEscape = \"\\\\\" + (octal || hex || unicodeCodePoint || unicode);\n      return this.error(message + \" \" + invalidEscape, {\n        offset: ((ref2 = options.offsetInChunk) != null ? ref2 : 0) + match.index + before.length,\n        length: invalidEscape.length\n      });\n    };\n    Lexer.prototype.makeDelimitedLiteral = function (body, options) {\n      var regex;\n      if (options == null) {\n        options = {};\n      }\n      if (body === '' && options.delimiter === '/') {\n        body = '(?:)';\n      }\n      regex = RegExp(\"(\\\\\\\\\\\\\\\\)|(\\\\\\\\0(?=[1-7]))|\\\\\\\\?(\" + options.delimiter + \")|\\\\\\\\?(?:(\\\\n)|(\\\\r)|(\\\\u2028)|(\\\\u2029))|(\\\\\\\\.)\", \"g\");\n      body = body.replace(regex, function (match, backslash, nul, delimiter, lf, cr, ls, ps, other) {\n        switch (false) {\n          case !backslash:\n            if (options.double) {\n              return backslash + backslash;\n            } else {\n              return backslash;\n            }\n          case !nul:\n            return '\\\\x00';\n          case !delimiter:\n            return \"\\\\\" + delimiter;\n          case !lf:\n            return '\\\\n';\n          case !cr:\n            return '\\\\r';\n          case !ls:\n            return '\\\\u2028';\n          case !ps:\n            return '\\\\u2029';\n          case !other:\n            if (options.double) {\n              return \"\\\\\" + other;\n            } else {\n              return other;\n            }\n        }\n      });\n      return \"\" + options.delimiter + body + options.delimiter;\n    };\n    Lexer.prototype.error = function (message, options) {\n      var first_column, first_line, location, ref2, ref3, ref4;\n      if (options == null) {\n        options = {};\n      }\n      location = 'first_line' in options ? options : ((ref3 = this.getLineAndColumnFromChunk((ref2 = options.offset) != null ? ref2 : 0), first_line = ref3[0], first_column = ref3[1], ref3), {\n        first_line: first_line,\n        first_column: first_column,\n        last_column: first_column + ((ref4 = options.length) != null ? ref4 : 1) - 1\n      });\n      return throwSyntaxError(message, location);\n    };\n    return Lexer;\n  }();\n  isUnassignable = function (name, displayName) {\n    if (displayName == null) {\n      displayName = name;\n    }\n    switch (false) {\n      case indexOf.call(slice.call(JS_KEYWORDS).concat(slice.call(COFFEE_KEYWORDS)), name) < 0:\n        return \"keyword '\" + displayName + \"' can't be assigned\";\n      case indexOf.call(STRICT_PROSCRIBED, name) < 0:\n        return \"'\" + displayName + \"' can't be assigned\";\n      case indexOf.call(RESERVED, name) < 0:\n        return \"reserved word '\" + displayName + \"' can't be assigned\";\n      default:\n        return false;\n    }\n  };\n  exports.isUnassignable = isUnassignable;\n  isForFrom = function (prev) {\n    var ref2;\n    if (prev[0] === 'IDENTIFIER') {\n      if (prev[1] === 'from') {\n        prev[1][0] = 'IDENTIFIER';\n        true;\n      }\n      return true;\n    } else if (prev[0] === 'FOR') {\n      return false;\n    } else if ((ref2 = prev[1]) === '{' || ref2 === '[' || ref2 === ',' || ref2 === ':') {\n      return false;\n    } else {\n      return true;\n    }\n  };\n  JS_KEYWORDS = ['true', 'false', 'null', 'this', 'new', 'delete', 'typeof', 'in', 'instanceof', 'return', 'throw', 'break', 'continue', 'debugger', 'yield', 'if', 'else', 'switch', 'for', 'while', 'do', 'try', 'catch', 'finally', 'class', 'extends', 'super', 'import', 'export', 'default'];\n  COFFEE_KEYWORDS = ['undefined', 'Infinity', 'NaN', 'then', 'unless', 'until', 'loop', 'of', 'by', 'when'];\n  COFFEE_ALIAS_MAP = {\n    and: '&&',\n    or: '||',\n    is: '==',\n    isnt: '!=',\n    not: '!',\n    yes: 'true',\n    no: 'false',\n    on: 'true',\n    off: 'false'\n  };\n  COFFEE_ALIASES = function () {\n    var results;\n    results = [];\n    for (key in COFFEE_ALIAS_MAP) {\n      results.push(key);\n    }\n    return results;\n  }();\n  COFFEE_KEYWORDS = COFFEE_KEYWORDS.concat(COFFEE_ALIASES);\n  RESERVED = ['case', 'function', 'var', 'void', 'with', 'const', 'let', 'enum', 'native', 'implements', 'interface', 'package', 'private', 'protected', 'public', 'static'];\n  STRICT_PROSCRIBED = ['arguments', 'eval'];\n  exports.JS_FORBIDDEN = JS_KEYWORDS.concat(RESERVED).concat(STRICT_PROSCRIBED);\n  BOM = 65279;\n  IDENTIFIER = /^(?!\\d)((?:(?!\\s)[$\\w\\x7f-\\uffff])+)([^\\n\\S]*:(?!:))?/;\n  NUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i;\n  OPERATOR = /^(?:[-=]>|[-+*\\/%<>&|^!?=]=|>>>=?|([-+:])\\1|([&|<>*\\/%])\\2=?|\\?(\\.|::)|\\.{2,3})/;\n  WHITESPACE = /^[^\\n\\S]+/;\n  COMMENT = /^###([^#][\\s\\S]*?)(?:###[^\\n\\S]*|###$)|^(?:\\s*#(?!##[^#]).*)+/;\n  CODE = /^[-=]>/;\n  MULTI_DENT = /^(?:\\n[^\\n\\S]*)+/;\n  JSTOKEN = /^`(?!``)((?:[^`\\\\]|\\\\[\\s\\S])*)`/;\n  HERE_JSTOKEN = /^```((?:[^`\\\\]|\\\\[\\s\\S]|`(?!``))*)```/;\n  STRING_START = /^(?:'''|\"\"\"|'|\")/;\n  STRING_SINGLE = /^(?:[^\\\\']|\\\\[\\s\\S])*/;\n  STRING_DOUBLE = /^(?:[^\\\\\"#]|\\\\[\\s\\S]|\\#(?!\\{))*/;\n  HEREDOC_SINGLE = /^(?:[^\\\\']|\\\\[\\s\\S]|'(?!''))*/;\n  HEREDOC_DOUBLE = /^(?:[^\\\\\"#]|\\\\[\\s\\S]|\"(?!\"\")|\\#(?!\\{))*/;\n  STRING_OMIT = /((?:\\\\\\\\)+)|\\\\[^\\S\\n]*\\n\\s*/g;\n  SIMPLE_STRING_OMIT = /\\s*\\n\\s*/g;\n  HEREDOC_INDENT = /\\n+([^\\n\\S]*)(?=\\S)/g;\n  REGEX = /^\\/(?!\\/)((?:[^[\\/\\n\\\\]|\\\\[^\\n]|\\[(?:\\\\[^\\n]|[^\\]\\n\\\\])*\\])*)(\\/)?/;\n  REGEX_FLAGS = /^\\w*/;\n  VALID_FLAGS = /^(?!.*(.).*\\1)[imguy]*$/;\n  HEREGEX = /^(?:[^\\\\\\/#]|\\\\[\\s\\S]|\\/(?!\\/\\/)|\\#(?!\\{))*/;\n  HEREGEX_OMIT = /((?:\\\\\\\\)+)|\\\\(\\s)|\\s+(?:#.*)?/g;\n  REGEX_ILLEGAL = /^(\\/|\\/{3}\\s*)(\\*)/;\n  POSSIBLY_DIVISION = /^\\/=?\\s/;\n  HERECOMMENT_ILLEGAL = /\\*\\//;\n  LINE_CONTINUER = /^\\s*(?:,|\\??\\.(?![.\\d])|::)/;\n  STRING_INVALID_ESCAPE = /((?:^|[^\\\\])(?:\\\\\\\\)*)\\\\(?:(0[0-7]|[1-7])|(x(?![\\da-fA-F]{2}).{0,2})|(u\\{(?![\\da-fA-F]{1,}\\})[^}]*\\}?)|(u(?!\\{|[\\da-fA-F]{4}).{0,4}))/;\n  REGEX_INVALID_ESCAPE = /((?:^|[^\\\\])(?:\\\\\\\\)*)\\\\(?:(0[0-7])|(x(?![\\da-fA-F]{2}).{0,2})|(u\\{(?![\\da-fA-F]{1,}\\})[^}]*\\}?)|(u(?!\\{|[\\da-fA-F]{4}).{0,4}))/;\n  UNICODE_CODE_POINT_ESCAPE = /(\\\\\\\\)|\\\\u\\{([\\da-fA-F]+)\\}/g;\n  LEADING_BLANK_LINE = /^[^\\n\\S]*\\n/;\n  TRAILING_BLANK_LINE = /\\n[^\\n\\S]*$/;\n  TRAILING_SPACES = /\\s+$/;\n  COMPOUND_ASSIGN = ['-=', '+=', '/=', '*=', '%=', '||=', '&&=', '?=', '<<=', '>>=', '>>>=', '&=', '^=', '|=', '**=', '//=', '%%='];\n  UNARY = ['NEW', 'TYPEOF', 'DELETE', 'DO'];\n  UNARY_MATH = ['!', '~'];\n  SHIFT = ['<<', '>>', '>>>'];\n  COMPARE = ['==', '!=', '<', '>', '<=', '>='];\n  MATH = ['*', '/', '%', '//', '%%'];\n  RELATION = ['IN', 'OF', 'INSTANCEOF'];\n  BOOL = ['TRUE', 'FALSE'];\n  CALLABLE = ['IDENTIFIER', 'PROPERTY', ')', ']', '?', '@', 'THIS', 'SUPER'];\n  INDEXABLE = CALLABLE.concat(['NUMBER', 'INFINITY', 'NAN', 'STRING', 'STRING_END', 'REGEX', 'REGEX_END', 'BOOL', 'NULL', 'UNDEFINED', '}', '::']);\n  NOT_REGEX = INDEXABLE.concat(['++', '--']);\n  LINE_BREAK = ['INDENT', 'OUTDENT', 'TERMINATOR'];\n  INDENTABLE_CLOSERS = [')', '}', ']'];\n  UNFINISHED = ['\\\\', '.', '?.', '?::', 'UNARY', 'MATH', 'UNARY_MATH', '+', '-', '**', 'SHIFT', 'RELATION', 'COMPARE', '&', '^', '|', '&&', '||', 'BIN?', 'THROW', 'EXTENDS', 'DEFAULT'];\n}).call(this);","map":{"version":3,"names":["BOM","BOOL","CALLABLE","CODE","COFFEE_ALIASES","COFFEE_ALIAS_MAP","COFFEE_KEYWORDS","COMMENT","COMPARE","COMPOUND_ASSIGN","HERECOMMENT_ILLEGAL","HEREDOC_DOUBLE","HEREDOC_INDENT","HEREDOC_SINGLE","HEREGEX","HEREGEX_OMIT","HERE_JSTOKEN","IDENTIFIER","INDENTABLE_CLOSERS","INDEXABLE","INVERSES","JSTOKEN","JS_KEYWORDS","LEADING_BLANK_LINE","LINE_BREAK","LINE_CONTINUER","Lexer","MATH","MULTI_DENT","NOT_REGEX","NUMBER","OPERATOR","POSSIBLY_DIVISION","REGEX","REGEX_FLAGS","REGEX_ILLEGAL","REGEX_INVALID_ESCAPE","RELATION","RESERVED","Rewriter","SHIFT","SIMPLE_STRING_OMIT","STRICT_PROSCRIBED","STRING_DOUBLE","STRING_INVALID_ESCAPE","STRING_OMIT","STRING_SINGLE","STRING_START","TRAILING_BLANK_LINE","TRAILING_SPACES","UNARY","UNARY_MATH","UNFINISHED","UNICODE_CODE_POINT_ESCAPE","VALID_FLAGS","WHITESPACE","compact","count","invertLiterate","isForFrom","isUnassignable","key","locationDataToString","ref","ref1","repeat","starts","throwSyntaxError","indexOf","item","i","l","length","slice","require","exports","prototype","tokenize","code","opts","consumed","end","ref2","literate","indent","baseIndent","indebt","outdebt","indents","ends","tokens","seenFor","seenImport","seenExport","importSpecifierList","exportSpecifierList","chunkLine","line","chunkColumn","column","clean","chunk","identifierToken","commentToken","whitespaceToken","lineToken","stringToken","numberToken","regexToken","jsToken","literalToken","getLineAndColumnFromChunk","untilBalanced","index","closeIndentation","pop","error","tag","origin","rewrite","charCodeAt","replace","test","alias","colon","colonOffset","id","idLength","input","match","poppedToken","prev","ref3","ref4","ref5","ref6","ref7","ref8","ref9","tagToken","exec","token","value","call","spaced","toUpperCase","first_line","first_column","lastIndexOf","base","lexedLength","number","numberValue","offset","charAt","parseInt","parseFloat","toString","$","attempt","delimiter","doc","heredoc","indentRegex","quote","regex","matchWithInterpolations","j","len","results","push","join","RegExp","mergeInterpolationTokens","_this","formatString","comment","here","script","string","Math","ceil","body","closed","flags","validateEscapes","isRegex","offsetInChunk","formatRegex","makeToken","formatHeregex","makeDelimitedLiteral","double","diff","noNewlines","size","unfinished","suppressNewlines","newlineToken","outdentToken","moveOut","outdentLength","decreasedIndent","dent","lastIndent","pair","nline","message","skipToken","tagParameters","concat","stack","tok","close","firstToken","lastToken","nested","open","str","strPart","splice","substr","last_line","last_column","options","fn","converted","firstEmptyStringIndex","firstIndex","locationToken","lparen","plusToken","rparen","tokensToPush","apply","wanted","lastLine","lineCount","split","lastCharacter","locationData","replaceUnicodeCodePointEscapes","unicodeCodePointToUnicodeEscapes","codePoint","high","low","toUnicodeEscape","val","floor","escapedBackslash","codePointHex","codePointDecimal","before","hex","invalidEscape","invalidEscapeRegex","octal","unicode","unicodeCodePoint","backslash","nul","lf","cr","ls","ps","other","location","name","displayName","and","or","is","isnt","not","yes","no","on","off","JS_FORBIDDEN"],"sources":["/home/kali/Desktop/c++/proshop/node_modules/coffee-script/lib/coffee-script/lexer.js"],"sourcesContent":["// Generated by CoffeeScript 1.12.7\n(function() {\n  var BOM, BOOL, CALLABLE, CODE, COFFEE_ALIASES, COFFEE_ALIAS_MAP, COFFEE_KEYWORDS, COMMENT, COMPARE, COMPOUND_ASSIGN, HERECOMMENT_ILLEGAL, HEREDOC_DOUBLE, HEREDOC_INDENT, HEREDOC_SINGLE, HEREGEX, HEREGEX_OMIT, HERE_JSTOKEN, IDENTIFIER, INDENTABLE_CLOSERS, INDEXABLE, INVERSES, JSTOKEN, JS_KEYWORDS, LEADING_BLANK_LINE, LINE_BREAK, LINE_CONTINUER, Lexer, MATH, MULTI_DENT, NOT_REGEX, NUMBER, OPERATOR, POSSIBLY_DIVISION, REGEX, REGEX_FLAGS, REGEX_ILLEGAL, REGEX_INVALID_ESCAPE, RELATION, RESERVED, Rewriter, SHIFT, SIMPLE_STRING_OMIT, STRICT_PROSCRIBED, STRING_DOUBLE, STRING_INVALID_ESCAPE, STRING_OMIT, STRING_SINGLE, STRING_START, TRAILING_BLANK_LINE, TRAILING_SPACES, UNARY, UNARY_MATH, UNFINISHED, UNICODE_CODE_POINT_ESCAPE, VALID_FLAGS, WHITESPACE, compact, count, invertLiterate, isForFrom, isUnassignable, key, locationDataToString, ref, ref1, repeat, starts, throwSyntaxError,\n    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n    slice = [].slice;\n\n  ref = require('./rewriter'), Rewriter = ref.Rewriter, INVERSES = ref.INVERSES;\n\n  ref1 = require('./helpers'), count = ref1.count, starts = ref1.starts, compact = ref1.compact, repeat = ref1.repeat, invertLiterate = ref1.invertLiterate, locationDataToString = ref1.locationDataToString, throwSyntaxError = ref1.throwSyntaxError;\n\n  exports.Lexer = Lexer = (function() {\n    function Lexer() {}\n\n    Lexer.prototype.tokenize = function(code, opts) {\n      var consumed, end, i, ref2;\n      if (opts == null) {\n        opts = {};\n      }\n      this.literate = opts.literate;\n      this.indent = 0;\n      this.baseIndent = 0;\n      this.indebt = 0;\n      this.outdebt = 0;\n      this.indents = [];\n      this.ends = [];\n      this.tokens = [];\n      this.seenFor = false;\n      this.seenImport = false;\n      this.seenExport = false;\n      this.importSpecifierList = false;\n      this.exportSpecifierList = false;\n      this.chunkLine = opts.line || 0;\n      this.chunkColumn = opts.column || 0;\n      code = this.clean(code);\n      i = 0;\n      while (this.chunk = code.slice(i)) {\n        consumed = this.identifierToken() || this.commentToken() || this.whitespaceToken() || this.lineToken() || this.stringToken() || this.numberToken() || this.regexToken() || this.jsToken() || this.literalToken();\n        ref2 = this.getLineAndColumnFromChunk(consumed), this.chunkLine = ref2[0], this.chunkColumn = ref2[1];\n        i += consumed;\n        if (opts.untilBalanced && this.ends.length === 0) {\n          return {\n            tokens: this.tokens,\n            index: i\n          };\n        }\n      }\n      this.closeIndentation();\n      if (end = this.ends.pop()) {\n        this.error(\"missing \" + end.tag, end.origin[2]);\n      }\n      if (opts.rewrite === false) {\n        return this.tokens;\n      }\n      return (new Rewriter).rewrite(this.tokens);\n    };\n\n    Lexer.prototype.clean = function(code) {\n      if (code.charCodeAt(0) === BOM) {\n        code = code.slice(1);\n      }\n      code = code.replace(/\\r/g, '').replace(TRAILING_SPACES, '');\n      if (WHITESPACE.test(code)) {\n        code = \"\\n\" + code;\n        this.chunkLine--;\n      }\n      if (this.literate) {\n        code = invertLiterate(code);\n      }\n      return code;\n    };\n\n    Lexer.prototype.identifierToken = function() {\n      var alias, colon, colonOffset, id, idLength, input, match, poppedToken, prev, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, tag, tagToken;\n      if (!(match = IDENTIFIER.exec(this.chunk))) {\n        return 0;\n      }\n      input = match[0], id = match[1], colon = match[2];\n      idLength = id.length;\n      poppedToken = void 0;\n      if (id === 'own' && this.tag() === 'FOR') {\n        this.token('OWN', id);\n        return id.length;\n      }\n      if (id === 'from' && this.tag() === 'YIELD') {\n        this.token('FROM', id);\n        return id.length;\n      }\n      if (id === 'as' && this.seenImport) {\n        if (this.value() === '*') {\n          this.tokens[this.tokens.length - 1][0] = 'IMPORT_ALL';\n        } else if (ref2 = this.value(), indexOf.call(COFFEE_KEYWORDS, ref2) >= 0) {\n          this.tokens[this.tokens.length - 1][0] = 'IDENTIFIER';\n        }\n        if ((ref3 = this.tag()) === 'DEFAULT' || ref3 === 'IMPORT_ALL' || ref3 === 'IDENTIFIER') {\n          this.token('AS', id);\n          return id.length;\n        }\n      }\n      if (id === 'as' && this.seenExport && ((ref4 = this.tag()) === 'IDENTIFIER' || ref4 === 'DEFAULT')) {\n        this.token('AS', id);\n        return id.length;\n      }\n      if (id === 'default' && this.seenExport && ((ref5 = this.tag()) === 'EXPORT' || ref5 === 'AS')) {\n        this.token('DEFAULT', id);\n        return id.length;\n      }\n      ref6 = this.tokens, prev = ref6[ref6.length - 1];\n      tag = colon || (prev != null) && (((ref7 = prev[0]) === '.' || ref7 === '?.' || ref7 === '::' || ref7 === '?::') || !prev.spaced && prev[0] === '@') ? 'PROPERTY' : 'IDENTIFIER';\n      if (tag === 'IDENTIFIER' && (indexOf.call(JS_KEYWORDS, id) >= 0 || indexOf.call(COFFEE_KEYWORDS, id) >= 0) && !(this.exportSpecifierList && indexOf.call(COFFEE_KEYWORDS, id) >= 0)) {\n        tag = id.toUpperCase();\n        if (tag === 'WHEN' && (ref8 = this.tag(), indexOf.call(LINE_BREAK, ref8) >= 0)) {\n          tag = 'LEADING_WHEN';\n        } else if (tag === 'FOR') {\n          this.seenFor = true;\n        } else if (tag === 'UNLESS') {\n          tag = 'IF';\n        } else if (tag === 'IMPORT') {\n          this.seenImport = true;\n        } else if (tag === 'EXPORT') {\n          this.seenExport = true;\n        } else if (indexOf.call(UNARY, tag) >= 0) {\n          tag = 'UNARY';\n        } else if (indexOf.call(RELATION, tag) >= 0) {\n          if (tag !== 'INSTANCEOF' && this.seenFor) {\n            tag = 'FOR' + tag;\n            this.seenFor = false;\n          } else {\n            tag = 'RELATION';\n            if (this.value() === '!') {\n              poppedToken = this.tokens.pop();\n              id = '!' + id;\n            }\n          }\n        }\n      } else if (tag === 'IDENTIFIER' && this.seenFor && id === 'from' && isForFrom(prev)) {\n        tag = 'FORFROM';\n        this.seenFor = false;\n      }\n      if (tag === 'IDENTIFIER' && indexOf.call(RESERVED, id) >= 0) {\n        this.error(\"reserved word '\" + id + \"'\", {\n          length: id.length\n        });\n      }\n      if (tag !== 'PROPERTY') {\n        if (indexOf.call(COFFEE_ALIASES, id) >= 0) {\n          alias = id;\n          id = COFFEE_ALIAS_MAP[id];\n        }\n        tag = (function() {\n          switch (id) {\n            case '!':\n              return 'UNARY';\n            case '==':\n            case '!=':\n              return 'COMPARE';\n            case 'true':\n            case 'false':\n              return 'BOOL';\n            case 'break':\n            case 'continue':\n            case 'debugger':\n              return 'STATEMENT';\n            case '&&':\n            case '||':\n              return id;\n            default:\n              return tag;\n          }\n        })();\n      }\n      tagToken = this.token(tag, id, 0, idLength);\n      if (alias) {\n        tagToken.origin = [tag, alias, tagToken[2]];\n      }\n      if (poppedToken) {\n        ref9 = [poppedToken[2].first_line, poppedToken[2].first_column], tagToken[2].first_line = ref9[0], tagToken[2].first_column = ref9[1];\n      }\n      if (colon) {\n        colonOffset = input.lastIndexOf(':');\n        this.token(':', ':', colonOffset, colon.length);\n      }\n      return input.length;\n    };\n\n    Lexer.prototype.numberToken = function() {\n      var base, lexedLength, match, number, numberValue, ref2, tag;\n      if (!(match = NUMBER.exec(this.chunk))) {\n        return 0;\n      }\n      number = match[0];\n      lexedLength = number.length;\n      switch (false) {\n        case !/^0[BOX]/.test(number):\n          this.error(\"radix prefix in '\" + number + \"' must be lowercase\", {\n            offset: 1\n          });\n          break;\n        case !/^(?!0x).*E/.test(number):\n          this.error(\"exponential notation in '\" + number + \"' must be indicated with a lowercase 'e'\", {\n            offset: number.indexOf('E')\n          });\n          break;\n        case !/^0\\d*[89]/.test(number):\n          this.error(\"decimal literal '\" + number + \"' must not be prefixed with '0'\", {\n            length: lexedLength\n          });\n          break;\n        case !/^0\\d+/.test(number):\n          this.error(\"octal literal '\" + number + \"' must be prefixed with '0o'\", {\n            length: lexedLength\n          });\n      }\n      base = (function() {\n        switch (number.charAt(1)) {\n          case 'b':\n            return 2;\n          case 'o':\n            return 8;\n          case 'x':\n            return 16;\n          default:\n            return null;\n        }\n      })();\n      numberValue = base != null ? parseInt(number.slice(2), base) : parseFloat(number);\n      if ((ref2 = number.charAt(1)) === 'b' || ref2 === 'o') {\n        number = \"0x\" + (numberValue.toString(16));\n      }\n      tag = numberValue === 2e308 ? 'INFINITY' : 'NUMBER';\n      this.token(tag, number, 0, lexedLength);\n      return lexedLength;\n    };\n\n    Lexer.prototype.stringToken = function() {\n      var $, attempt, delimiter, doc, end, heredoc, i, indent, indentRegex, match, quote, ref2, ref3, regex, token, tokens;\n      quote = (STRING_START.exec(this.chunk) || [])[0];\n      if (!quote) {\n        return 0;\n      }\n      if (this.tokens.length && this.value() === 'from' && (this.seenImport || this.seenExport)) {\n        this.tokens[this.tokens.length - 1][0] = 'FROM';\n      }\n      regex = (function() {\n        switch (quote) {\n          case \"'\":\n            return STRING_SINGLE;\n          case '\"':\n            return STRING_DOUBLE;\n          case \"'''\":\n            return HEREDOC_SINGLE;\n          case '\"\"\"':\n            return HEREDOC_DOUBLE;\n        }\n      })();\n      heredoc = quote.length === 3;\n      ref2 = this.matchWithInterpolations(regex, quote), tokens = ref2.tokens, end = ref2.index;\n      $ = tokens.length - 1;\n      delimiter = quote.charAt(0);\n      if (heredoc) {\n        indent = null;\n        doc = ((function() {\n          var j, len, results;\n          results = [];\n          for (i = j = 0, len = tokens.length; j < len; i = ++j) {\n            token = tokens[i];\n            if (token[0] === 'NEOSTRING') {\n              results.push(token[1]);\n            }\n          }\n          return results;\n        })()).join('#{}');\n        while (match = HEREDOC_INDENT.exec(doc)) {\n          attempt = match[1];\n          if (indent === null || (0 < (ref3 = attempt.length) && ref3 < indent.length)) {\n            indent = attempt;\n          }\n        }\n        if (indent) {\n          indentRegex = RegExp(\"\\\\n\" + indent, \"g\");\n        }\n        this.mergeInterpolationTokens(tokens, {\n          delimiter: delimiter\n        }, (function(_this) {\n          return function(value, i) {\n            value = _this.formatString(value, {\n              delimiter: quote\n            });\n            if (indentRegex) {\n              value = value.replace(indentRegex, '\\n');\n            }\n            if (i === 0) {\n              value = value.replace(LEADING_BLANK_LINE, '');\n            }\n            if (i === $) {\n              value = value.replace(TRAILING_BLANK_LINE, '');\n            }\n            return value;\n          };\n        })(this));\n      } else {\n        this.mergeInterpolationTokens(tokens, {\n          delimiter: delimiter\n        }, (function(_this) {\n          return function(value, i) {\n            value = _this.formatString(value, {\n              delimiter: quote\n            });\n            value = value.replace(SIMPLE_STRING_OMIT, function(match, offset) {\n              if ((i === 0 && offset === 0) || (i === $ && offset + match.length === value.length)) {\n                return '';\n              } else {\n                return ' ';\n              }\n            });\n            return value;\n          };\n        })(this));\n      }\n      return end;\n    };\n\n    Lexer.prototype.commentToken = function() {\n      var comment, here, match;\n      if (!(match = this.chunk.match(COMMENT))) {\n        return 0;\n      }\n      comment = match[0], here = match[1];\n      if (here) {\n        if (match = HERECOMMENT_ILLEGAL.exec(comment)) {\n          this.error(\"block comments cannot contain \" + match[0], {\n            offset: match.index,\n            length: match[0].length\n          });\n        }\n        if (here.indexOf('\\n') >= 0) {\n          here = here.replace(RegExp(\"\\\\n\" + (repeat(' ', this.indent)), \"g\"), '\\n');\n        }\n        this.token('HERECOMMENT', here, 0, comment.length);\n      }\n      return comment.length;\n    };\n\n    Lexer.prototype.jsToken = function() {\n      var match, script;\n      if (!(this.chunk.charAt(0) === '`' && (match = HERE_JSTOKEN.exec(this.chunk) || JSTOKEN.exec(this.chunk)))) {\n        return 0;\n      }\n      script = match[1].replace(/\\\\+(`|$)/g, function(string) {\n        return string.slice(-Math.ceil(string.length / 2));\n      });\n      this.token('JS', script, 0, match[0].length);\n      return match[0].length;\n    };\n\n    Lexer.prototype.regexToken = function() {\n      var body, closed, end, flags, index, match, origin, prev, ref2, ref3, ref4, regex, tokens;\n      switch (false) {\n        case !(match = REGEX_ILLEGAL.exec(this.chunk)):\n          this.error(\"regular expressions cannot begin with \" + match[2], {\n            offset: match.index + match[1].length\n          });\n          break;\n        case !(match = this.matchWithInterpolations(HEREGEX, '///')):\n          tokens = match.tokens, index = match.index;\n          break;\n        case !(match = REGEX.exec(this.chunk)):\n          regex = match[0], body = match[1], closed = match[2];\n          this.validateEscapes(body, {\n            isRegex: true,\n            offsetInChunk: 1\n          });\n          body = this.formatRegex(body, {\n            delimiter: '/'\n          });\n          index = regex.length;\n          ref2 = this.tokens, prev = ref2[ref2.length - 1];\n          if (prev) {\n            if (prev.spaced && (ref3 = prev[0], indexOf.call(CALLABLE, ref3) >= 0)) {\n              if (!closed || POSSIBLY_DIVISION.test(regex)) {\n                return 0;\n              }\n            } else if (ref4 = prev[0], indexOf.call(NOT_REGEX, ref4) >= 0) {\n              return 0;\n            }\n          }\n          if (!closed) {\n            this.error('missing / (unclosed regex)');\n          }\n          break;\n        default:\n          return 0;\n      }\n      flags = REGEX_FLAGS.exec(this.chunk.slice(index))[0];\n      end = index + flags.length;\n      origin = this.makeToken('REGEX', null, 0, end);\n      switch (false) {\n        case !!VALID_FLAGS.test(flags):\n          this.error(\"invalid regular expression flags \" + flags, {\n            offset: index,\n            length: flags.length\n          });\n          break;\n        case !(regex || tokens.length === 1):\n          if (body == null) {\n            body = this.formatHeregex(tokens[0][1]);\n          }\n          this.token('REGEX', \"\" + (this.makeDelimitedLiteral(body, {\n            delimiter: '/'\n          })) + flags, 0, end, origin);\n          break;\n        default:\n          this.token('REGEX_START', '(', 0, 0, origin);\n          this.token('IDENTIFIER', 'RegExp', 0, 0);\n          this.token('CALL_START', '(', 0, 0);\n          this.mergeInterpolationTokens(tokens, {\n            delimiter: '\"',\n            double: true\n          }, this.formatHeregex);\n          if (flags) {\n            this.token(',', ',', index - 1, 0);\n            this.token('STRING', '\"' + flags + '\"', index - 1, flags.length);\n          }\n          this.token(')', ')', end - 1, 0);\n          this.token('REGEX_END', ')', end - 1, 0);\n      }\n      return end;\n    };\n\n    Lexer.prototype.lineToken = function() {\n      var diff, indent, match, noNewlines, size;\n      if (!(match = MULTI_DENT.exec(this.chunk))) {\n        return 0;\n      }\n      indent = match[0];\n      this.seenFor = false;\n      if (!this.importSpecifierList) {\n        this.seenImport = false;\n      }\n      if (!this.exportSpecifierList) {\n        this.seenExport = false;\n      }\n      size = indent.length - 1 - indent.lastIndexOf('\\n');\n      noNewlines = this.unfinished();\n      if (size - this.indebt === this.indent) {\n        if (noNewlines) {\n          this.suppressNewlines();\n        } else {\n          this.newlineToken(0);\n        }\n        return indent.length;\n      }\n      if (size > this.indent) {\n        if (noNewlines) {\n          this.indebt = size - this.indent;\n          this.suppressNewlines();\n          return indent.length;\n        }\n        if (!this.tokens.length) {\n          this.baseIndent = this.indent = size;\n          return indent.length;\n        }\n        diff = size - this.indent + this.outdebt;\n        this.token('INDENT', diff, indent.length - size, size);\n        this.indents.push(diff);\n        this.ends.push({\n          tag: 'OUTDENT'\n        });\n        this.outdebt = this.indebt = 0;\n        this.indent = size;\n      } else if (size < this.baseIndent) {\n        this.error('missing indentation', {\n          offset: indent.length\n        });\n      } else {\n        this.indebt = 0;\n        this.outdentToken(this.indent - size, noNewlines, indent.length);\n      }\n      return indent.length;\n    };\n\n    Lexer.prototype.outdentToken = function(moveOut, noNewlines, outdentLength) {\n      var decreasedIndent, dent, lastIndent, ref2;\n      decreasedIndent = this.indent - moveOut;\n      while (moveOut > 0) {\n        lastIndent = this.indents[this.indents.length - 1];\n        if (!lastIndent) {\n          moveOut = 0;\n        } else if (lastIndent === this.outdebt) {\n          moveOut -= this.outdebt;\n          this.outdebt = 0;\n        } else if (lastIndent < this.outdebt) {\n          this.outdebt -= lastIndent;\n          moveOut -= lastIndent;\n        } else {\n          dent = this.indents.pop() + this.outdebt;\n          if (outdentLength && (ref2 = this.chunk[outdentLength], indexOf.call(INDENTABLE_CLOSERS, ref2) >= 0)) {\n            decreasedIndent -= dent - moveOut;\n            moveOut = dent;\n          }\n          this.outdebt = 0;\n          this.pair('OUTDENT');\n          this.token('OUTDENT', moveOut, 0, outdentLength);\n          moveOut -= dent;\n        }\n      }\n      if (dent) {\n        this.outdebt -= moveOut;\n      }\n      while (this.value() === ';') {\n        this.tokens.pop();\n      }\n      if (!(this.tag() === 'TERMINATOR' || noNewlines)) {\n        this.token('TERMINATOR', '\\n', outdentLength, 0);\n      }\n      this.indent = decreasedIndent;\n      return this;\n    };\n\n    Lexer.prototype.whitespaceToken = function() {\n      var match, nline, prev, ref2;\n      if (!((match = WHITESPACE.exec(this.chunk)) || (nline = this.chunk.charAt(0) === '\\n'))) {\n        return 0;\n      }\n      ref2 = this.tokens, prev = ref2[ref2.length - 1];\n      if (prev) {\n        prev[match ? 'spaced' : 'newLine'] = true;\n      }\n      if (match) {\n        return match[0].length;\n      } else {\n        return 0;\n      }\n    };\n\n    Lexer.prototype.newlineToken = function(offset) {\n      while (this.value() === ';') {\n        this.tokens.pop();\n      }\n      if (this.tag() !== 'TERMINATOR') {\n        this.token('TERMINATOR', '\\n', offset, 0);\n      }\n      return this;\n    };\n\n    Lexer.prototype.suppressNewlines = function() {\n      if (this.value() === '\\\\') {\n        this.tokens.pop();\n      }\n      return this;\n    };\n\n    Lexer.prototype.literalToken = function() {\n      var match, message, origin, prev, ref2, ref3, ref4, ref5, ref6, skipToken, tag, token, value;\n      if (match = OPERATOR.exec(this.chunk)) {\n        value = match[0];\n        if (CODE.test(value)) {\n          this.tagParameters();\n        }\n      } else {\n        value = this.chunk.charAt(0);\n      }\n      tag = value;\n      ref2 = this.tokens, prev = ref2[ref2.length - 1];\n      if (prev && indexOf.call(['='].concat(slice.call(COMPOUND_ASSIGN)), value) >= 0) {\n        skipToken = false;\n        if (value === '=' && ((ref3 = prev[1]) === '||' || ref3 === '&&') && !prev.spaced) {\n          prev[0] = 'COMPOUND_ASSIGN';\n          prev[1] += '=';\n          prev = this.tokens[this.tokens.length - 2];\n          skipToken = true;\n        }\n        if (prev && prev[0] !== 'PROPERTY') {\n          origin = (ref4 = prev.origin) != null ? ref4 : prev;\n          message = isUnassignable(prev[1], origin[1]);\n          if (message) {\n            this.error(message, origin[2]);\n          }\n        }\n        if (skipToken) {\n          return value.length;\n        }\n      }\n      if (value === '{' && this.seenImport) {\n        this.importSpecifierList = true;\n      } else if (this.importSpecifierList && value === '}') {\n        this.importSpecifierList = false;\n      } else if (value === '{' && (prev != null ? prev[0] : void 0) === 'EXPORT') {\n        this.exportSpecifierList = true;\n      } else if (this.exportSpecifierList && value === '}') {\n        this.exportSpecifierList = false;\n      }\n      if (value === ';') {\n        this.seenFor = this.seenImport = this.seenExport = false;\n        tag = 'TERMINATOR';\n      } else if (value === '*' && prev[0] === 'EXPORT') {\n        tag = 'EXPORT_ALL';\n      } else if (indexOf.call(MATH, value) >= 0) {\n        tag = 'MATH';\n      } else if (indexOf.call(COMPARE, value) >= 0) {\n        tag = 'COMPARE';\n      } else if (indexOf.call(COMPOUND_ASSIGN, value) >= 0) {\n        tag = 'COMPOUND_ASSIGN';\n      } else if (indexOf.call(UNARY, value) >= 0) {\n        tag = 'UNARY';\n      } else if (indexOf.call(UNARY_MATH, value) >= 0) {\n        tag = 'UNARY_MATH';\n      } else if (indexOf.call(SHIFT, value) >= 0) {\n        tag = 'SHIFT';\n      } else if (value === '?' && (prev != null ? prev.spaced : void 0)) {\n        tag = 'BIN?';\n      } else if (prev && !prev.spaced) {\n        if (value === '(' && (ref5 = prev[0], indexOf.call(CALLABLE, ref5) >= 0)) {\n          if (prev[0] === '?') {\n            prev[0] = 'FUNC_EXIST';\n          }\n          tag = 'CALL_START';\n        } else if (value === '[' && (ref6 = prev[0], indexOf.call(INDEXABLE, ref6) >= 0)) {\n          tag = 'INDEX_START';\n          switch (prev[0]) {\n            case '?':\n              prev[0] = 'INDEX_SOAK';\n          }\n        }\n      }\n      token = this.makeToken(tag, value);\n      switch (value) {\n        case '(':\n        case '{':\n        case '[':\n          this.ends.push({\n            tag: INVERSES[value],\n            origin: token\n          });\n          break;\n        case ')':\n        case '}':\n        case ']':\n          this.pair(value);\n      }\n      this.tokens.push(token);\n      return value.length;\n    };\n\n    Lexer.prototype.tagParameters = function() {\n      var i, stack, tok, tokens;\n      if (this.tag() !== ')') {\n        return this;\n      }\n      stack = [];\n      tokens = this.tokens;\n      i = tokens.length;\n      tokens[--i][0] = 'PARAM_END';\n      while (tok = tokens[--i]) {\n        switch (tok[0]) {\n          case ')':\n            stack.push(tok);\n            break;\n          case '(':\n          case 'CALL_START':\n            if (stack.length) {\n              stack.pop();\n            } else if (tok[0] === '(') {\n              tok[0] = 'PARAM_START';\n              return this;\n            } else {\n              return this;\n            }\n        }\n      }\n      return this;\n    };\n\n    Lexer.prototype.closeIndentation = function() {\n      return this.outdentToken(this.indent);\n    };\n\n    Lexer.prototype.matchWithInterpolations = function(regex, delimiter) {\n      var close, column, firstToken, index, lastToken, line, nested, offsetInChunk, open, ref2, ref3, ref4, str, strPart, tokens;\n      tokens = [];\n      offsetInChunk = delimiter.length;\n      if (this.chunk.slice(0, offsetInChunk) !== delimiter) {\n        return null;\n      }\n      str = this.chunk.slice(offsetInChunk);\n      while (true) {\n        strPart = regex.exec(str)[0];\n        this.validateEscapes(strPart, {\n          isRegex: delimiter.charAt(0) === '/',\n          offsetInChunk: offsetInChunk\n        });\n        tokens.push(this.makeToken('NEOSTRING', strPart, offsetInChunk));\n        str = str.slice(strPart.length);\n        offsetInChunk += strPart.length;\n        if (str.slice(0, 2) !== '#{') {\n          break;\n        }\n        ref2 = this.getLineAndColumnFromChunk(offsetInChunk + 1), line = ref2[0], column = ref2[1];\n        ref3 = new Lexer().tokenize(str.slice(1), {\n          line: line,\n          column: column,\n          untilBalanced: true\n        }), nested = ref3.tokens, index = ref3.index;\n        index += 1;\n        open = nested[0], close = nested[nested.length - 1];\n        open[0] = open[1] = '(';\n        close[0] = close[1] = ')';\n        close.origin = ['', 'end of interpolation', close[2]];\n        if (((ref4 = nested[1]) != null ? ref4[0] : void 0) === 'TERMINATOR') {\n          nested.splice(1, 1);\n        }\n        tokens.push(['TOKENS', nested]);\n        str = str.slice(index);\n        offsetInChunk += index;\n      }\n      if (str.slice(0, delimiter.length) !== delimiter) {\n        this.error(\"missing \" + delimiter, {\n          length: delimiter.length\n        });\n      }\n      firstToken = tokens[0], lastToken = tokens[tokens.length - 1];\n      firstToken[2].first_column -= delimiter.length;\n      if (lastToken[1].substr(-1) === '\\n') {\n        lastToken[2].last_line += 1;\n        lastToken[2].last_column = delimiter.length - 1;\n      } else {\n        lastToken[2].last_column += delimiter.length;\n      }\n      if (lastToken[1].length === 0) {\n        lastToken[2].last_column -= 1;\n      }\n      return {\n        tokens: tokens,\n        index: offsetInChunk + delimiter.length\n      };\n    };\n\n    Lexer.prototype.mergeInterpolationTokens = function(tokens, options, fn) {\n      var converted, firstEmptyStringIndex, firstIndex, i, j, lastToken, len, locationToken, lparen, plusToken, ref2, rparen, tag, token, tokensToPush, value;\n      if (tokens.length > 1) {\n        lparen = this.token('STRING_START', '(', 0, 0);\n      }\n      firstIndex = this.tokens.length;\n      for (i = j = 0, len = tokens.length; j < len; i = ++j) {\n        token = tokens[i];\n        tag = token[0], value = token[1];\n        switch (tag) {\n          case 'TOKENS':\n            if (value.length === 2) {\n              continue;\n            }\n            locationToken = value[0];\n            tokensToPush = value;\n            break;\n          case 'NEOSTRING':\n            converted = fn.call(this, token[1], i);\n            if (converted.length === 0) {\n              if (i === 0) {\n                firstEmptyStringIndex = this.tokens.length;\n              } else {\n                continue;\n              }\n            }\n            if (i === 2 && (firstEmptyStringIndex != null)) {\n              this.tokens.splice(firstEmptyStringIndex, 2);\n            }\n            token[0] = 'STRING';\n            token[1] = this.makeDelimitedLiteral(converted, options);\n            locationToken = token;\n            tokensToPush = [token];\n        }\n        if (this.tokens.length > firstIndex) {\n          plusToken = this.token('+', '+');\n          plusToken[2] = {\n            first_line: locationToken[2].first_line,\n            first_column: locationToken[2].first_column,\n            last_line: locationToken[2].first_line,\n            last_column: locationToken[2].first_column\n          };\n        }\n        (ref2 = this.tokens).push.apply(ref2, tokensToPush);\n      }\n      if (lparen) {\n        lastToken = tokens[tokens.length - 1];\n        lparen.origin = [\n          'STRING', null, {\n            first_line: lparen[2].first_line,\n            first_column: lparen[2].first_column,\n            last_line: lastToken[2].last_line,\n            last_column: lastToken[2].last_column\n          }\n        ];\n        rparen = this.token('STRING_END', ')');\n        return rparen[2] = {\n          first_line: lastToken[2].last_line,\n          first_column: lastToken[2].last_column,\n          last_line: lastToken[2].last_line,\n          last_column: lastToken[2].last_column\n        };\n      }\n    };\n\n    Lexer.prototype.pair = function(tag) {\n      var lastIndent, prev, ref2, ref3, wanted;\n      ref2 = this.ends, prev = ref2[ref2.length - 1];\n      if (tag !== (wanted = prev != null ? prev.tag : void 0)) {\n        if ('OUTDENT' !== wanted) {\n          this.error(\"unmatched \" + tag);\n        }\n        ref3 = this.indents, lastIndent = ref3[ref3.length - 1];\n        this.outdentToken(lastIndent, true);\n        return this.pair(tag);\n      }\n      return this.ends.pop();\n    };\n\n    Lexer.prototype.getLineAndColumnFromChunk = function(offset) {\n      var column, lastLine, lineCount, ref2, string;\n      if (offset === 0) {\n        return [this.chunkLine, this.chunkColumn];\n      }\n      if (offset >= this.chunk.length) {\n        string = this.chunk;\n      } else {\n        string = this.chunk.slice(0, +(offset - 1) + 1 || 9e9);\n      }\n      lineCount = count(string, '\\n');\n      column = this.chunkColumn;\n      if (lineCount > 0) {\n        ref2 = string.split('\\n'), lastLine = ref2[ref2.length - 1];\n        column = lastLine.length;\n      } else {\n        column += string.length;\n      }\n      return [this.chunkLine + lineCount, column];\n    };\n\n    Lexer.prototype.makeToken = function(tag, value, offsetInChunk, length) {\n      var lastCharacter, locationData, ref2, ref3, token;\n      if (offsetInChunk == null) {\n        offsetInChunk = 0;\n      }\n      if (length == null) {\n        length = value.length;\n      }\n      locationData = {};\n      ref2 = this.getLineAndColumnFromChunk(offsetInChunk), locationData.first_line = ref2[0], locationData.first_column = ref2[1];\n      lastCharacter = length > 0 ? length - 1 : 0;\n      ref3 = this.getLineAndColumnFromChunk(offsetInChunk + lastCharacter), locationData.last_line = ref3[0], locationData.last_column = ref3[1];\n      token = [tag, value, locationData];\n      return token;\n    };\n\n    Lexer.prototype.token = function(tag, value, offsetInChunk, length, origin) {\n      var token;\n      token = this.makeToken(tag, value, offsetInChunk, length);\n      if (origin) {\n        token.origin = origin;\n      }\n      this.tokens.push(token);\n      return token;\n    };\n\n    Lexer.prototype.tag = function() {\n      var ref2, token;\n      ref2 = this.tokens, token = ref2[ref2.length - 1];\n      return token != null ? token[0] : void 0;\n    };\n\n    Lexer.prototype.value = function() {\n      var ref2, token;\n      ref2 = this.tokens, token = ref2[ref2.length - 1];\n      return token != null ? token[1] : void 0;\n    };\n\n    Lexer.prototype.unfinished = function() {\n      var ref2;\n      return LINE_CONTINUER.test(this.chunk) || (ref2 = this.tag(), indexOf.call(UNFINISHED, ref2) >= 0);\n    };\n\n    Lexer.prototype.formatString = function(str, options) {\n      return this.replaceUnicodeCodePointEscapes(str.replace(STRING_OMIT, '$1'), options);\n    };\n\n    Lexer.prototype.formatHeregex = function(str) {\n      return this.formatRegex(str.replace(HEREGEX_OMIT, '$1$2'), {\n        delimiter: '///'\n      });\n    };\n\n    Lexer.prototype.formatRegex = function(str, options) {\n      return this.replaceUnicodeCodePointEscapes(str, options);\n    };\n\n    Lexer.prototype.unicodeCodePointToUnicodeEscapes = function(codePoint) {\n      var high, low, toUnicodeEscape;\n      toUnicodeEscape = function(val) {\n        var str;\n        str = val.toString(16);\n        return \"\\\\u\" + (repeat('0', 4 - str.length)) + str;\n      };\n      if (codePoint < 0x10000) {\n        return toUnicodeEscape(codePoint);\n      }\n      high = Math.floor((codePoint - 0x10000) / 0x400) + 0xD800;\n      low = (codePoint - 0x10000) % 0x400 + 0xDC00;\n      return \"\" + (toUnicodeEscape(high)) + (toUnicodeEscape(low));\n    };\n\n    Lexer.prototype.replaceUnicodeCodePointEscapes = function(str, options) {\n      return str.replace(UNICODE_CODE_POINT_ESCAPE, (function(_this) {\n        return function(match, escapedBackslash, codePointHex, offset) {\n          var codePointDecimal;\n          if (escapedBackslash) {\n            return escapedBackslash;\n          }\n          codePointDecimal = parseInt(codePointHex, 16);\n          if (codePointDecimal > 0x10ffff) {\n            _this.error(\"unicode code point escapes greater than \\\\u{10ffff} are not allowed\", {\n              offset: offset + options.delimiter.length,\n              length: codePointHex.length + 4\n            });\n          }\n          return _this.unicodeCodePointToUnicodeEscapes(codePointDecimal);\n        };\n      })(this));\n    };\n\n    Lexer.prototype.validateEscapes = function(str, options) {\n      var before, hex, invalidEscape, invalidEscapeRegex, match, message, octal, ref2, unicode, unicodeCodePoint;\n      if (options == null) {\n        options = {};\n      }\n      invalidEscapeRegex = options.isRegex ? REGEX_INVALID_ESCAPE : STRING_INVALID_ESCAPE;\n      match = invalidEscapeRegex.exec(str);\n      if (!match) {\n        return;\n      }\n      match[0], before = match[1], octal = match[2], hex = match[3], unicodeCodePoint = match[4], unicode = match[5];\n      message = octal ? \"octal escape sequences are not allowed\" : \"invalid escape sequence\";\n      invalidEscape = \"\\\\\" + (octal || hex || unicodeCodePoint || unicode);\n      return this.error(message + \" \" + invalidEscape, {\n        offset: ((ref2 = options.offsetInChunk) != null ? ref2 : 0) + match.index + before.length,\n        length: invalidEscape.length\n      });\n    };\n\n    Lexer.prototype.makeDelimitedLiteral = function(body, options) {\n      var regex;\n      if (options == null) {\n        options = {};\n      }\n      if (body === '' && options.delimiter === '/') {\n        body = '(?:)';\n      }\n      regex = RegExp(\"(\\\\\\\\\\\\\\\\)|(\\\\\\\\0(?=[1-7]))|\\\\\\\\?(\" + options.delimiter + \")|\\\\\\\\?(?:(\\\\n)|(\\\\r)|(\\\\u2028)|(\\\\u2029))|(\\\\\\\\.)\", \"g\");\n      body = body.replace(regex, function(match, backslash, nul, delimiter, lf, cr, ls, ps, other) {\n        switch (false) {\n          case !backslash:\n            if (options.double) {\n              return backslash + backslash;\n            } else {\n              return backslash;\n            }\n          case !nul:\n            return '\\\\x00';\n          case !delimiter:\n            return \"\\\\\" + delimiter;\n          case !lf:\n            return '\\\\n';\n          case !cr:\n            return '\\\\r';\n          case !ls:\n            return '\\\\u2028';\n          case !ps:\n            return '\\\\u2029';\n          case !other:\n            if (options.double) {\n              return \"\\\\\" + other;\n            } else {\n              return other;\n            }\n        }\n      });\n      return \"\" + options.delimiter + body + options.delimiter;\n    };\n\n    Lexer.prototype.error = function(message, options) {\n      var first_column, first_line, location, ref2, ref3, ref4;\n      if (options == null) {\n        options = {};\n      }\n      location = 'first_line' in options ? options : ((ref3 = this.getLineAndColumnFromChunk((ref2 = options.offset) != null ? ref2 : 0), first_line = ref3[0], first_column = ref3[1], ref3), {\n        first_line: first_line,\n        first_column: first_column,\n        last_column: first_column + ((ref4 = options.length) != null ? ref4 : 1) - 1\n      });\n      return throwSyntaxError(message, location);\n    };\n\n    return Lexer;\n\n  })();\n\n  isUnassignable = function(name, displayName) {\n    if (displayName == null) {\n      displayName = name;\n    }\n    switch (false) {\n      case indexOf.call(slice.call(JS_KEYWORDS).concat(slice.call(COFFEE_KEYWORDS)), name) < 0:\n        return \"keyword '\" + displayName + \"' can't be assigned\";\n      case indexOf.call(STRICT_PROSCRIBED, name) < 0:\n        return \"'\" + displayName + \"' can't be assigned\";\n      case indexOf.call(RESERVED, name) < 0:\n        return \"reserved word '\" + displayName + \"' can't be assigned\";\n      default:\n        return false;\n    }\n  };\n\n  exports.isUnassignable = isUnassignable;\n\n  isForFrom = function(prev) {\n    var ref2;\n    if (prev[0] === 'IDENTIFIER') {\n      if (prev[1] === 'from') {\n        prev[1][0] = 'IDENTIFIER';\n        true;\n      }\n      return true;\n    } else if (prev[0] === 'FOR') {\n      return false;\n    } else if ((ref2 = prev[1]) === '{' || ref2 === '[' || ref2 === ',' || ref2 === ':') {\n      return false;\n    } else {\n      return true;\n    }\n  };\n\n  JS_KEYWORDS = ['true', 'false', 'null', 'this', 'new', 'delete', 'typeof', 'in', 'instanceof', 'return', 'throw', 'break', 'continue', 'debugger', 'yield', 'if', 'else', 'switch', 'for', 'while', 'do', 'try', 'catch', 'finally', 'class', 'extends', 'super', 'import', 'export', 'default'];\n\n  COFFEE_KEYWORDS = ['undefined', 'Infinity', 'NaN', 'then', 'unless', 'until', 'loop', 'of', 'by', 'when'];\n\n  COFFEE_ALIAS_MAP = {\n    and: '&&',\n    or: '||',\n    is: '==',\n    isnt: '!=',\n    not: '!',\n    yes: 'true',\n    no: 'false',\n    on: 'true',\n    off: 'false'\n  };\n\n  COFFEE_ALIASES = (function() {\n    var results;\n    results = [];\n    for (key in COFFEE_ALIAS_MAP) {\n      results.push(key);\n    }\n    return results;\n  })();\n\n  COFFEE_KEYWORDS = COFFEE_KEYWORDS.concat(COFFEE_ALIASES);\n\n  RESERVED = ['case', 'function', 'var', 'void', 'with', 'const', 'let', 'enum', 'native', 'implements', 'interface', 'package', 'private', 'protected', 'public', 'static'];\n\n  STRICT_PROSCRIBED = ['arguments', 'eval'];\n\n  exports.JS_FORBIDDEN = JS_KEYWORDS.concat(RESERVED).concat(STRICT_PROSCRIBED);\n\n  BOM = 65279;\n\n  IDENTIFIER = /^(?!\\d)((?:(?!\\s)[$\\w\\x7f-\\uffff])+)([^\\n\\S]*:(?!:))?/;\n\n  NUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i;\n\n  OPERATOR = /^(?:[-=]>|[-+*\\/%<>&|^!?=]=|>>>=?|([-+:])\\1|([&|<>*\\/%])\\2=?|\\?(\\.|::)|\\.{2,3})/;\n\n  WHITESPACE = /^[^\\n\\S]+/;\n\n  COMMENT = /^###([^#][\\s\\S]*?)(?:###[^\\n\\S]*|###$)|^(?:\\s*#(?!##[^#]).*)+/;\n\n  CODE = /^[-=]>/;\n\n  MULTI_DENT = /^(?:\\n[^\\n\\S]*)+/;\n\n  JSTOKEN = /^`(?!``)((?:[^`\\\\]|\\\\[\\s\\S])*)`/;\n\n  HERE_JSTOKEN = /^```((?:[^`\\\\]|\\\\[\\s\\S]|`(?!``))*)```/;\n\n  STRING_START = /^(?:'''|\"\"\"|'|\")/;\n\n  STRING_SINGLE = /^(?:[^\\\\']|\\\\[\\s\\S])*/;\n\n  STRING_DOUBLE = /^(?:[^\\\\\"#]|\\\\[\\s\\S]|\\#(?!\\{))*/;\n\n  HEREDOC_SINGLE = /^(?:[^\\\\']|\\\\[\\s\\S]|'(?!''))*/;\n\n  HEREDOC_DOUBLE = /^(?:[^\\\\\"#]|\\\\[\\s\\S]|\"(?!\"\")|\\#(?!\\{))*/;\n\n  STRING_OMIT = /((?:\\\\\\\\)+)|\\\\[^\\S\\n]*\\n\\s*/g;\n\n  SIMPLE_STRING_OMIT = /\\s*\\n\\s*/g;\n\n  HEREDOC_INDENT = /\\n+([^\\n\\S]*)(?=\\S)/g;\n\n  REGEX = /^\\/(?!\\/)((?:[^[\\/\\n\\\\]|\\\\[^\\n]|\\[(?:\\\\[^\\n]|[^\\]\\n\\\\])*\\])*)(\\/)?/;\n\n  REGEX_FLAGS = /^\\w*/;\n\n  VALID_FLAGS = /^(?!.*(.).*\\1)[imguy]*$/;\n\n  HEREGEX = /^(?:[^\\\\\\/#]|\\\\[\\s\\S]|\\/(?!\\/\\/)|\\#(?!\\{))*/;\n\n  HEREGEX_OMIT = /((?:\\\\\\\\)+)|\\\\(\\s)|\\s+(?:#.*)?/g;\n\n  REGEX_ILLEGAL = /^(\\/|\\/{3}\\s*)(\\*)/;\n\n  POSSIBLY_DIVISION = /^\\/=?\\s/;\n\n  HERECOMMENT_ILLEGAL = /\\*\\//;\n\n  LINE_CONTINUER = /^\\s*(?:,|\\??\\.(?![.\\d])|::)/;\n\n  STRING_INVALID_ESCAPE = /((?:^|[^\\\\])(?:\\\\\\\\)*)\\\\(?:(0[0-7]|[1-7])|(x(?![\\da-fA-F]{2}).{0,2})|(u\\{(?![\\da-fA-F]{1,}\\})[^}]*\\}?)|(u(?!\\{|[\\da-fA-F]{4}).{0,4}))/;\n\n  REGEX_INVALID_ESCAPE = /((?:^|[^\\\\])(?:\\\\\\\\)*)\\\\(?:(0[0-7])|(x(?![\\da-fA-F]{2}).{0,2})|(u\\{(?![\\da-fA-F]{1,}\\})[^}]*\\}?)|(u(?!\\{|[\\da-fA-F]{4}).{0,4}))/;\n\n  UNICODE_CODE_POINT_ESCAPE = /(\\\\\\\\)|\\\\u\\{([\\da-fA-F]+)\\}/g;\n\n  LEADING_BLANK_LINE = /^[^\\n\\S]*\\n/;\n\n  TRAILING_BLANK_LINE = /\\n[^\\n\\S]*$/;\n\n  TRAILING_SPACES = /\\s+$/;\n\n  COMPOUND_ASSIGN = ['-=', '+=', '/=', '*=', '%=', '||=', '&&=', '?=', '<<=', '>>=', '>>>=', '&=', '^=', '|=', '**=', '//=', '%%='];\n\n  UNARY = ['NEW', 'TYPEOF', 'DELETE', 'DO'];\n\n  UNARY_MATH = ['!', '~'];\n\n  SHIFT = ['<<', '>>', '>>>'];\n\n  COMPARE = ['==', '!=', '<', '>', '<=', '>='];\n\n  MATH = ['*', '/', '%', '//', '%%'];\n\n  RELATION = ['IN', 'OF', 'INSTANCEOF'];\n\n  BOOL = ['TRUE', 'FALSE'];\n\n  CALLABLE = ['IDENTIFIER', 'PROPERTY', ')', ']', '?', '@', 'THIS', 'SUPER'];\n\n  INDEXABLE = CALLABLE.concat(['NUMBER', 'INFINITY', 'NAN', 'STRING', 'STRING_END', 'REGEX', 'REGEX_END', 'BOOL', 'NULL', 'UNDEFINED', '}', '::']);\n\n  NOT_REGEX = INDEXABLE.concat(['++', '--']);\n\n  LINE_BREAK = ['INDENT', 'OUTDENT', 'TERMINATOR'];\n\n  INDENTABLE_CLOSERS = [')', '}', ']'];\n\n  UNFINISHED = ['\\\\', '.', '?.', '?::', 'UNARY', 'MATH', 'UNARY_MATH', '+', '-', '**', 'SHIFT', 'RELATION', 'COMPARE', '&', '^', '|', '&&', '||', 'BIN?', 'THROW', 'EXTENDS', 'DEFAULT'];\n\n}).call(this);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}