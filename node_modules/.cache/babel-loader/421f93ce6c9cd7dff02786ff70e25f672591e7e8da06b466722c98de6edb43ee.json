{"ast":null,"code":"// Generated by CoffeeScript 1.12.7\n(function () {\n  var BALANCED_PAIRS,\n    CALL_CLOSERS,\n    EXPRESSION_CLOSE,\n    EXPRESSION_END,\n    EXPRESSION_START,\n    IMPLICIT_CALL,\n    IMPLICIT_END,\n    IMPLICIT_FUNC,\n    IMPLICIT_UNSPACED_CALL,\n    INVERSES,\n    LINEBREAKS,\n    Rewriter,\n    SINGLE_CLOSERS,\n    SINGLE_LINERS,\n    generate,\n    k,\n    left,\n    len,\n    ref,\n    rite,\n    indexOf = [].indexOf || function (item) {\n      for (var i = 0, l = this.length; i < l; i++) {\n        if (i in this && this[i] === item) return i;\n      }\n      return -1;\n    },\n    slice = [].slice;\n  generate = function (tag, value, origin) {\n    var tok;\n    tok = [tag, value];\n    tok.generated = true;\n    if (origin) {\n      tok.origin = origin;\n    }\n    return tok;\n  };\n  exports.Rewriter = Rewriter = function () {\n    function Rewriter() {}\n    Rewriter.prototype.rewrite = function (tokens1) {\n      this.tokens = tokens1;\n      this.removeLeadingNewlines();\n      this.closeOpenCalls();\n      this.closeOpenIndexes();\n      this.normalizeLines();\n      this.tagPostfixConditionals();\n      this.addImplicitBracesAndParens();\n      this.addLocationDataToGeneratedTokens();\n      this.fixOutdentLocationData();\n      return this.tokens;\n    };\n    Rewriter.prototype.scanTokens = function (block) {\n      var i, token, tokens;\n      tokens = this.tokens;\n      i = 0;\n      while (token = tokens[i]) {\n        i += block.call(this, token, i, tokens);\n      }\n      return true;\n    };\n    Rewriter.prototype.detectEnd = function (i, condition, action) {\n      var levels, ref, ref1, token, tokens;\n      tokens = this.tokens;\n      levels = 0;\n      while (token = tokens[i]) {\n        if (levels === 0 && condition.call(this, token, i)) {\n          return action.call(this, token, i);\n        }\n        if (!token || levels < 0) {\n          return action.call(this, token, i - 1);\n        }\n        if (ref = token[0], indexOf.call(EXPRESSION_START, ref) >= 0) {\n          levels += 1;\n        } else if (ref1 = token[0], indexOf.call(EXPRESSION_END, ref1) >= 0) {\n          levels -= 1;\n        }\n        i += 1;\n      }\n      return i - 1;\n    };\n    Rewriter.prototype.removeLeadingNewlines = function () {\n      var i, k, len, ref, tag;\n      ref = this.tokens;\n      for (i = k = 0, len = ref.length; k < len; i = ++k) {\n        tag = ref[i][0];\n        if (tag !== 'TERMINATOR') {\n          break;\n        }\n      }\n      if (i) {\n        return this.tokens.splice(0, i);\n      }\n    };\n    Rewriter.prototype.closeOpenCalls = function () {\n      var action, condition;\n      condition = function (token, i) {\n        var ref;\n        return (ref = token[0]) === ')' || ref === 'CALL_END' || token[0] === 'OUTDENT' && this.tag(i - 1) === ')';\n      };\n      action = function (token, i) {\n        return this.tokens[token[0] === 'OUTDENT' ? i - 1 : i][0] = 'CALL_END';\n      };\n      return this.scanTokens(function (token, i) {\n        if (token[0] === 'CALL_START') {\n          this.detectEnd(i + 1, condition, action);\n        }\n        return 1;\n      });\n    };\n    Rewriter.prototype.closeOpenIndexes = function () {\n      var action, condition;\n      condition = function (token, i) {\n        var ref;\n        return (ref = token[0]) === ']' || ref === 'INDEX_END';\n      };\n      action = function (token, i) {\n        return token[0] = 'INDEX_END';\n      };\n      return this.scanTokens(function (token, i) {\n        if (token[0] === 'INDEX_START') {\n          this.detectEnd(i + 1, condition, action);\n        }\n        return 1;\n      });\n    };\n    Rewriter.prototype.indexOfTag = function () {\n      var fuzz, i, j, k, pattern, ref, ref1;\n      i = arguments[0], pattern = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      fuzz = 0;\n      for (j = k = 0, ref = pattern.length; 0 <= ref ? k < ref : k > ref; j = 0 <= ref ? ++k : --k) {\n        while (this.tag(i + j + fuzz) === 'HERECOMMENT') {\n          fuzz += 2;\n        }\n        if (pattern[j] == null) {\n          continue;\n        }\n        if (typeof pattern[j] === 'string') {\n          pattern[j] = [pattern[j]];\n        }\n        if (ref1 = this.tag(i + j + fuzz), indexOf.call(pattern[j], ref1) < 0) {\n          return -1;\n        }\n      }\n      return i + j + fuzz - 1;\n    };\n    Rewriter.prototype.looksObjectish = function (j) {\n      var end, index;\n      if (this.indexOfTag(j, '@', null, ':') > -1 || this.indexOfTag(j, null, ':') > -1) {\n        return true;\n      }\n      index = this.indexOfTag(j, EXPRESSION_START);\n      if (index > -1) {\n        end = null;\n        this.detectEnd(index + 1, function (token) {\n          var ref;\n          return ref = token[0], indexOf.call(EXPRESSION_END, ref) >= 0;\n        }, function (token, i) {\n          return end = i;\n        });\n        if (this.tag(end + 1) === ':') {\n          return true;\n        }\n      }\n      return false;\n    };\n    Rewriter.prototype.findTagsBackwards = function (i, tags) {\n      var backStack, ref, ref1, ref2, ref3, ref4, ref5;\n      backStack = [];\n      while (i >= 0 && (backStack.length || (ref2 = this.tag(i), indexOf.call(tags, ref2) < 0) && ((ref3 = this.tag(i), indexOf.call(EXPRESSION_START, ref3) < 0) || this.tokens[i].generated) && (ref4 = this.tag(i), indexOf.call(LINEBREAKS, ref4) < 0))) {\n        if (ref = this.tag(i), indexOf.call(EXPRESSION_END, ref) >= 0) {\n          backStack.push(this.tag(i));\n        }\n        if ((ref1 = this.tag(i), indexOf.call(EXPRESSION_START, ref1) >= 0) && backStack.length) {\n          backStack.pop();\n        }\n        i -= 1;\n      }\n      return ref5 = this.tag(i), indexOf.call(tags, ref5) >= 0;\n    };\n    Rewriter.prototype.addImplicitBracesAndParens = function () {\n      var stack, start;\n      stack = [];\n      start = null;\n      return this.scanTokens(function (token, i, tokens) {\n        var endImplicitCall, endImplicitObject, forward, inImplicit, inImplicitCall, inImplicitControl, inImplicitObject, isImplicit, isImplicitCall, isImplicitObject, k, newLine, nextTag, offset, prevTag, prevToken, ref, ref1, ref2, ref3, ref4, ref5, s, sameLine, stackIdx, stackItem, stackTag, stackTop, startIdx, startImplicitCall, startImplicitObject, startsLine, tag;\n        tag = token[0];\n        prevTag = (prevToken = i > 0 ? tokens[i - 1] : [])[0];\n        nextTag = (i < tokens.length - 1 ? tokens[i + 1] : [])[0];\n        stackTop = function () {\n          return stack[stack.length - 1];\n        };\n        startIdx = i;\n        forward = function (n) {\n          return i - startIdx + n;\n        };\n        isImplicit = function (stackItem) {\n          var ref;\n          return stackItem != null ? (ref = stackItem[2]) != null ? ref.ours : void 0 : void 0;\n        };\n        isImplicitObject = function (stackItem) {\n          return isImplicit(stackItem) && (stackItem != null ? stackItem[0] : void 0) === '{';\n        };\n        isImplicitCall = function (stackItem) {\n          return isImplicit(stackItem) && (stackItem != null ? stackItem[0] : void 0) === '(';\n        };\n        inImplicit = function () {\n          return isImplicit(stackTop());\n        };\n        inImplicitCall = function () {\n          return isImplicitCall(stackTop());\n        };\n        inImplicitObject = function () {\n          return isImplicitObject(stackTop());\n        };\n        inImplicitControl = function () {\n          var ref;\n          return inImplicit && ((ref = stackTop()) != null ? ref[0] : void 0) === 'CONTROL';\n        };\n        startImplicitCall = function (j) {\n          var idx;\n          idx = j != null ? j : i;\n          stack.push(['(', idx, {\n            ours: true\n          }]);\n          tokens.splice(idx, 0, generate('CALL_START', '(', ['', 'implicit function call', token[2]]));\n          if (j == null) {\n            return i += 1;\n          }\n        };\n        endImplicitCall = function () {\n          stack.pop();\n          tokens.splice(i, 0, generate('CALL_END', ')', ['', 'end of input', token[2]]));\n          return i += 1;\n        };\n        startImplicitObject = function (j, startsLine) {\n          var idx, val;\n          if (startsLine == null) {\n            startsLine = true;\n          }\n          idx = j != null ? j : i;\n          stack.push(['{', idx, {\n            sameLine: true,\n            startsLine: startsLine,\n            ours: true\n          }]);\n          val = new String('{');\n          val.generated = true;\n          tokens.splice(idx, 0, generate('{', val, token));\n          if (j == null) {\n            return i += 1;\n          }\n        };\n        endImplicitObject = function (j) {\n          j = j != null ? j : i;\n          stack.pop();\n          tokens.splice(j, 0, generate('}', '}', token));\n          return i += 1;\n        };\n        if (inImplicitCall() && (tag === 'IF' || tag === 'TRY' || tag === 'FINALLY' || tag === 'CATCH' || tag === 'CLASS' || tag === 'SWITCH')) {\n          stack.push(['CONTROL', i, {\n            ours: true\n          }]);\n          return forward(1);\n        }\n        if (tag === 'INDENT' && inImplicit()) {\n          if (prevTag !== '=>' && prevTag !== '->' && prevTag !== '[' && prevTag !== '(' && prevTag !== ',' && prevTag !== '{' && prevTag !== 'TRY' && prevTag !== 'ELSE' && prevTag !== '=') {\n            while (inImplicitCall()) {\n              endImplicitCall();\n            }\n          }\n          if (inImplicitControl()) {\n            stack.pop();\n          }\n          stack.push([tag, i]);\n          return forward(1);\n        }\n        if (indexOf.call(EXPRESSION_START, tag) >= 0) {\n          stack.push([tag, i]);\n          return forward(1);\n        }\n        if (indexOf.call(EXPRESSION_END, tag) >= 0) {\n          while (inImplicit()) {\n            if (inImplicitCall()) {\n              endImplicitCall();\n            } else if (inImplicitObject()) {\n              endImplicitObject();\n            } else {\n              stack.pop();\n            }\n          }\n          start = stack.pop();\n        }\n        if ((indexOf.call(IMPLICIT_FUNC, tag) >= 0 && token.spaced || tag === '?' && i > 0 && !tokens[i - 1].spaced) && (indexOf.call(IMPLICIT_CALL, nextTag) >= 0 || indexOf.call(IMPLICIT_UNSPACED_CALL, nextTag) >= 0 && !((ref = tokens[i + 1]) != null ? ref.spaced : void 0) && !((ref1 = tokens[i + 1]) != null ? ref1.newLine : void 0))) {\n          if (tag === '?') {\n            tag = token[0] = 'FUNC_EXIST';\n          }\n          startImplicitCall(i + 1);\n          return forward(2);\n        }\n        if (indexOf.call(IMPLICIT_FUNC, tag) >= 0 && this.indexOfTag(i + 1, 'INDENT') > -1 && this.looksObjectish(i + 2) && !this.findTagsBackwards(i, ['CLASS', 'EXTENDS', 'IF', 'CATCH', 'SWITCH', 'LEADING_WHEN', 'FOR', 'WHILE', 'UNTIL'])) {\n          startImplicitCall(i + 1);\n          stack.push(['INDENT', i + 2]);\n          return forward(3);\n        }\n        if (tag === ':') {\n          s = function () {\n            var ref2;\n            switch (false) {\n              case (ref2 = this.tag(i - 1), indexOf.call(EXPRESSION_END, ref2) < 0):\n                return start[1];\n              case this.tag(i - 2) !== '@':\n                return i - 2;\n              default:\n                return i - 1;\n            }\n          }.call(this);\n          while (this.tag(s - 2) === 'HERECOMMENT') {\n            s -= 2;\n          }\n          this.insideForDeclaration = nextTag === 'FOR';\n          startsLine = s === 0 || (ref2 = this.tag(s - 1), indexOf.call(LINEBREAKS, ref2) >= 0) || tokens[s - 1].newLine;\n          if (stackTop()) {\n            ref3 = stackTop(), stackTag = ref3[0], stackIdx = ref3[1];\n            if ((stackTag === '{' || stackTag === 'INDENT' && this.tag(stackIdx - 1) === '{') && (startsLine || this.tag(s - 1) === ',' || this.tag(s - 1) === '{')) {\n              return forward(1);\n            }\n          }\n          startImplicitObject(s, !!startsLine);\n          return forward(2);\n        }\n        if (indexOf.call(LINEBREAKS, tag) >= 0) {\n          for (k = stack.length - 1; k >= 0; k += -1) {\n            stackItem = stack[k];\n            if (!isImplicit(stackItem)) {\n              break;\n            }\n            if (isImplicitObject(stackItem)) {\n              stackItem[2].sameLine = false;\n            }\n          }\n        }\n        newLine = prevTag === 'OUTDENT' || prevToken.newLine;\n        if (indexOf.call(IMPLICIT_END, tag) >= 0 || indexOf.call(CALL_CLOSERS, tag) >= 0 && newLine) {\n          while (inImplicit()) {\n            ref4 = stackTop(), stackTag = ref4[0], stackIdx = ref4[1], (ref5 = ref4[2], sameLine = ref5.sameLine, startsLine = ref5.startsLine);\n            if (inImplicitCall() && prevTag !== ',') {\n              endImplicitCall();\n            } else if (inImplicitObject() && !this.insideForDeclaration && sameLine && tag !== 'TERMINATOR' && prevTag !== ':') {\n              endImplicitObject();\n            } else if (inImplicitObject() && tag === 'TERMINATOR' && prevTag !== ',' && !(startsLine && this.looksObjectish(i + 1))) {\n              if (nextTag === 'HERECOMMENT') {\n                return forward(1);\n              }\n              endImplicitObject();\n            } else {\n              break;\n            }\n          }\n        }\n        if (tag === ',' && !this.looksObjectish(i + 1) && inImplicitObject() && !this.insideForDeclaration && (nextTag !== 'TERMINATOR' || !this.looksObjectish(i + 2))) {\n          offset = nextTag === 'OUTDENT' ? 1 : 0;\n          while (inImplicitObject()) {\n            endImplicitObject(i + offset);\n          }\n        }\n        return forward(1);\n      });\n    };\n    Rewriter.prototype.addLocationDataToGeneratedTokens = function () {\n      return this.scanTokens(function (token, i, tokens) {\n        var column, line, nextLocation, prevLocation, ref, ref1;\n        if (token[2]) {\n          return 1;\n        }\n        if (!(token.generated || token.explicit)) {\n          return 1;\n        }\n        if (token[0] === '{' && (nextLocation = (ref = tokens[i + 1]) != null ? ref[2] : void 0)) {\n          line = nextLocation.first_line, column = nextLocation.first_column;\n        } else if (prevLocation = (ref1 = tokens[i - 1]) != null ? ref1[2] : void 0) {\n          line = prevLocation.last_line, column = prevLocation.last_column;\n        } else {\n          line = column = 0;\n        }\n        token[2] = {\n          first_line: line,\n          first_column: column,\n          last_line: line,\n          last_column: column\n        };\n        return 1;\n      });\n    };\n    Rewriter.prototype.fixOutdentLocationData = function () {\n      return this.scanTokens(function (token, i, tokens) {\n        var prevLocationData;\n        if (!(token[0] === 'OUTDENT' || token.generated && token[0] === 'CALL_END' || token.generated && token[0] === '}')) {\n          return 1;\n        }\n        prevLocationData = tokens[i - 1][2];\n        token[2] = {\n          first_line: prevLocationData.last_line,\n          first_column: prevLocationData.last_column,\n          last_line: prevLocationData.last_line,\n          last_column: prevLocationData.last_column\n        };\n        return 1;\n      });\n    };\n    Rewriter.prototype.normalizeLines = function () {\n      var action, condition, indent, outdent, starter;\n      starter = indent = outdent = null;\n      condition = function (token, i) {\n        var ref, ref1, ref2, ref3;\n        return token[1] !== ';' && (ref = token[0], indexOf.call(SINGLE_CLOSERS, ref) >= 0) && !(token[0] === 'TERMINATOR' && (ref1 = this.tag(i + 1), indexOf.call(EXPRESSION_CLOSE, ref1) >= 0)) && !(token[0] === 'ELSE' && starter !== 'THEN') && !(((ref2 = token[0]) === 'CATCH' || ref2 === 'FINALLY') && (starter === '->' || starter === '=>')) || (ref3 = token[0], indexOf.call(CALL_CLOSERS, ref3) >= 0) && (this.tokens[i - 1].newLine || this.tokens[i - 1][0] === 'OUTDENT');\n      };\n      action = function (token, i) {\n        return this.tokens.splice(this.tag(i - 1) === ',' ? i - 1 : i, 0, outdent);\n      };\n      return this.scanTokens(function (token, i, tokens) {\n        var j, k, ref, ref1, ref2, tag;\n        tag = token[0];\n        if (tag === 'TERMINATOR') {\n          if (this.tag(i + 1) === 'ELSE' && this.tag(i - 1) !== 'OUTDENT') {\n            tokens.splice.apply(tokens, [i, 1].concat(slice.call(this.indentation())));\n            return 1;\n          }\n          if (ref = this.tag(i + 1), indexOf.call(EXPRESSION_CLOSE, ref) >= 0) {\n            tokens.splice(i, 1);\n            return 0;\n          }\n        }\n        if (tag === 'CATCH') {\n          for (j = k = 1; k <= 2; j = ++k) {\n            if (!((ref1 = this.tag(i + j)) === 'OUTDENT' || ref1 === 'TERMINATOR' || ref1 === 'FINALLY')) {\n              continue;\n            }\n            tokens.splice.apply(tokens, [i + j, 0].concat(slice.call(this.indentation())));\n            return 2 + j;\n          }\n        }\n        if (indexOf.call(SINGLE_LINERS, tag) >= 0 && this.tag(i + 1) !== 'INDENT' && !(tag === 'ELSE' && this.tag(i + 1) === 'IF')) {\n          starter = tag;\n          ref2 = this.indentation(tokens[i]), indent = ref2[0], outdent = ref2[1];\n          if (starter === 'THEN') {\n            indent.fromThen = true;\n          }\n          tokens.splice(i + 1, 0, indent);\n          this.detectEnd(i + 2, condition, action);\n          if (tag === 'THEN') {\n            tokens.splice(i, 1);\n          }\n          return 1;\n        }\n        return 1;\n      });\n    };\n    Rewriter.prototype.tagPostfixConditionals = function () {\n      var action, condition, original;\n      original = null;\n      condition = function (token, i) {\n        var prevTag, tag;\n        tag = token[0];\n        prevTag = this.tokens[i - 1][0];\n        return tag === 'TERMINATOR' || tag === 'INDENT' && indexOf.call(SINGLE_LINERS, prevTag) < 0;\n      };\n      action = function (token, i) {\n        if (token[0] !== 'INDENT' || token.generated && !token.fromThen) {\n          return original[0] = 'POST_' + original[0];\n        }\n      };\n      return this.scanTokens(function (token, i) {\n        if (token[0] !== 'IF') {\n          return 1;\n        }\n        original = token;\n        this.detectEnd(i + 1, condition, action);\n        return 1;\n      });\n    };\n    Rewriter.prototype.indentation = function (origin) {\n      var indent, outdent;\n      indent = ['INDENT', 2];\n      outdent = ['OUTDENT', 2];\n      if (origin) {\n        indent.generated = outdent.generated = true;\n        indent.origin = outdent.origin = origin;\n      } else {\n        indent.explicit = outdent.explicit = true;\n      }\n      return [indent, outdent];\n    };\n    Rewriter.prototype.generate = generate;\n    Rewriter.prototype.tag = function (i) {\n      var ref;\n      return (ref = this.tokens[i]) != null ? ref[0] : void 0;\n    };\n    return Rewriter;\n  }();\n  BALANCED_PAIRS = [['(', ')'], ['[', ']'], ['{', '}'], ['INDENT', 'OUTDENT'], ['CALL_START', 'CALL_END'], ['PARAM_START', 'PARAM_END'], ['INDEX_START', 'INDEX_END'], ['STRING_START', 'STRING_END'], ['REGEX_START', 'REGEX_END']];\n  exports.INVERSES = INVERSES = {};\n  EXPRESSION_START = [];\n  EXPRESSION_END = [];\n  for (k = 0, len = BALANCED_PAIRS.length; k < len; k++) {\n    ref = BALANCED_PAIRS[k], left = ref[0], rite = ref[1];\n    EXPRESSION_START.push(INVERSES[rite] = left);\n    EXPRESSION_END.push(INVERSES[left] = rite);\n  }\n  EXPRESSION_CLOSE = ['CATCH', 'THEN', 'ELSE', 'FINALLY'].concat(EXPRESSION_END);\n  IMPLICIT_FUNC = ['IDENTIFIER', 'PROPERTY', 'SUPER', ')', 'CALL_END', ']', 'INDEX_END', '@', 'THIS'];\n  IMPLICIT_CALL = ['IDENTIFIER', 'PROPERTY', 'NUMBER', 'INFINITY', 'NAN', 'STRING', 'STRING_START', 'REGEX', 'REGEX_START', 'JS', 'NEW', 'PARAM_START', 'CLASS', 'IF', 'TRY', 'SWITCH', 'THIS', 'UNDEFINED', 'NULL', 'BOOL', 'UNARY', 'YIELD', 'UNARY_MATH', 'SUPER', 'THROW', '@', '->', '=>', '[', '(', '{', '--', '++'];\n  IMPLICIT_UNSPACED_CALL = ['+', '-'];\n  IMPLICIT_END = ['POST_IF', 'FOR', 'WHILE', 'UNTIL', 'WHEN', 'BY', 'LOOP', 'TERMINATOR'];\n  SINGLE_LINERS = ['ELSE', '->', '=>', 'TRY', 'FINALLY', 'THEN'];\n  SINGLE_CLOSERS = ['TERMINATOR', 'CATCH', 'FINALLY', 'ELSE', 'OUTDENT', 'LEADING_WHEN'];\n  LINEBREAKS = ['TERMINATOR', 'INDENT', 'OUTDENT'];\n  CALL_CLOSERS = ['.', '?.', '::', '?::'];\n}).call(this);","map":{"version":3,"names":["BALANCED_PAIRS","CALL_CLOSERS","EXPRESSION_CLOSE","EXPRESSION_END","EXPRESSION_START","IMPLICIT_CALL","IMPLICIT_END","IMPLICIT_FUNC","IMPLICIT_UNSPACED_CALL","INVERSES","LINEBREAKS","Rewriter","SINGLE_CLOSERS","SINGLE_LINERS","generate","k","left","len","ref","rite","indexOf","item","i","l","length","slice","tag","value","origin","tok","generated","exports","prototype","rewrite","tokens1","tokens","removeLeadingNewlines","closeOpenCalls","closeOpenIndexes","normalizeLines","tagPostfixConditionals","addImplicitBracesAndParens","addLocationDataToGeneratedTokens","fixOutdentLocationData","scanTokens","block","token","call","detectEnd","condition","action","levels","ref1","splice","indexOfTag","fuzz","j","pattern","arguments","looksObjectish","end","index","findTagsBackwards","tags","backStack","ref2","ref3","ref4","ref5","push","pop","stack","start","endImplicitCall","endImplicitObject","forward","inImplicit","inImplicitCall","inImplicitControl","inImplicitObject","isImplicit","isImplicitCall","isImplicitObject","newLine","nextTag","offset","prevTag","prevToken","s","sameLine","stackIdx","stackItem","stackTag","stackTop","startIdx","startImplicitCall","startImplicitObject","startsLine","n","ours","idx","val","String","spaced","insideForDeclaration","column","line","nextLocation","prevLocation","explicit","first_line","first_column","last_line","last_column","prevLocationData","indent","outdent","starter","apply","concat","indentation","fromThen","original"],"sources":["/home/kali/Desktop/c++/proshop/node_modules/coffee-script/lib/coffee-script/rewriter.js"],"sourcesContent":["// Generated by CoffeeScript 1.12.7\n(function() {\n  var BALANCED_PAIRS, CALL_CLOSERS, EXPRESSION_CLOSE, EXPRESSION_END, EXPRESSION_START, IMPLICIT_CALL, IMPLICIT_END, IMPLICIT_FUNC, IMPLICIT_UNSPACED_CALL, INVERSES, LINEBREAKS, Rewriter, SINGLE_CLOSERS, SINGLE_LINERS, generate, k, left, len, ref, rite,\n    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n    slice = [].slice;\n\n  generate = function(tag, value, origin) {\n    var tok;\n    tok = [tag, value];\n    tok.generated = true;\n    if (origin) {\n      tok.origin = origin;\n    }\n    return tok;\n  };\n\n  exports.Rewriter = Rewriter = (function() {\n    function Rewriter() {}\n\n    Rewriter.prototype.rewrite = function(tokens1) {\n      this.tokens = tokens1;\n      this.removeLeadingNewlines();\n      this.closeOpenCalls();\n      this.closeOpenIndexes();\n      this.normalizeLines();\n      this.tagPostfixConditionals();\n      this.addImplicitBracesAndParens();\n      this.addLocationDataToGeneratedTokens();\n      this.fixOutdentLocationData();\n      return this.tokens;\n    };\n\n    Rewriter.prototype.scanTokens = function(block) {\n      var i, token, tokens;\n      tokens = this.tokens;\n      i = 0;\n      while (token = tokens[i]) {\n        i += block.call(this, token, i, tokens);\n      }\n      return true;\n    };\n\n    Rewriter.prototype.detectEnd = function(i, condition, action) {\n      var levels, ref, ref1, token, tokens;\n      tokens = this.tokens;\n      levels = 0;\n      while (token = tokens[i]) {\n        if (levels === 0 && condition.call(this, token, i)) {\n          return action.call(this, token, i);\n        }\n        if (!token || levels < 0) {\n          return action.call(this, token, i - 1);\n        }\n        if (ref = token[0], indexOf.call(EXPRESSION_START, ref) >= 0) {\n          levels += 1;\n        } else if (ref1 = token[0], indexOf.call(EXPRESSION_END, ref1) >= 0) {\n          levels -= 1;\n        }\n        i += 1;\n      }\n      return i - 1;\n    };\n\n    Rewriter.prototype.removeLeadingNewlines = function() {\n      var i, k, len, ref, tag;\n      ref = this.tokens;\n      for (i = k = 0, len = ref.length; k < len; i = ++k) {\n        tag = ref[i][0];\n        if (tag !== 'TERMINATOR') {\n          break;\n        }\n      }\n      if (i) {\n        return this.tokens.splice(0, i);\n      }\n    };\n\n    Rewriter.prototype.closeOpenCalls = function() {\n      var action, condition;\n      condition = function(token, i) {\n        var ref;\n        return ((ref = token[0]) === ')' || ref === 'CALL_END') || token[0] === 'OUTDENT' && this.tag(i - 1) === ')';\n      };\n      action = function(token, i) {\n        return this.tokens[token[0] === 'OUTDENT' ? i - 1 : i][0] = 'CALL_END';\n      };\n      return this.scanTokens(function(token, i) {\n        if (token[0] === 'CALL_START') {\n          this.detectEnd(i + 1, condition, action);\n        }\n        return 1;\n      });\n    };\n\n    Rewriter.prototype.closeOpenIndexes = function() {\n      var action, condition;\n      condition = function(token, i) {\n        var ref;\n        return (ref = token[0]) === ']' || ref === 'INDEX_END';\n      };\n      action = function(token, i) {\n        return token[0] = 'INDEX_END';\n      };\n      return this.scanTokens(function(token, i) {\n        if (token[0] === 'INDEX_START') {\n          this.detectEnd(i + 1, condition, action);\n        }\n        return 1;\n      });\n    };\n\n    Rewriter.prototype.indexOfTag = function() {\n      var fuzz, i, j, k, pattern, ref, ref1;\n      i = arguments[0], pattern = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      fuzz = 0;\n      for (j = k = 0, ref = pattern.length; 0 <= ref ? k < ref : k > ref; j = 0 <= ref ? ++k : --k) {\n        while (this.tag(i + j + fuzz) === 'HERECOMMENT') {\n          fuzz += 2;\n        }\n        if (pattern[j] == null) {\n          continue;\n        }\n        if (typeof pattern[j] === 'string') {\n          pattern[j] = [pattern[j]];\n        }\n        if (ref1 = this.tag(i + j + fuzz), indexOf.call(pattern[j], ref1) < 0) {\n          return -1;\n        }\n      }\n      return i + j + fuzz - 1;\n    };\n\n    Rewriter.prototype.looksObjectish = function(j) {\n      var end, index;\n      if (this.indexOfTag(j, '@', null, ':') > -1 || this.indexOfTag(j, null, ':') > -1) {\n        return true;\n      }\n      index = this.indexOfTag(j, EXPRESSION_START);\n      if (index > -1) {\n        end = null;\n        this.detectEnd(index + 1, (function(token) {\n          var ref;\n          return ref = token[0], indexOf.call(EXPRESSION_END, ref) >= 0;\n        }), (function(token, i) {\n          return end = i;\n        }));\n        if (this.tag(end + 1) === ':') {\n          return true;\n        }\n      }\n      return false;\n    };\n\n    Rewriter.prototype.findTagsBackwards = function(i, tags) {\n      var backStack, ref, ref1, ref2, ref3, ref4, ref5;\n      backStack = [];\n      while (i >= 0 && (backStack.length || (ref2 = this.tag(i), indexOf.call(tags, ref2) < 0) && ((ref3 = this.tag(i), indexOf.call(EXPRESSION_START, ref3) < 0) || this.tokens[i].generated) && (ref4 = this.tag(i), indexOf.call(LINEBREAKS, ref4) < 0))) {\n        if (ref = this.tag(i), indexOf.call(EXPRESSION_END, ref) >= 0) {\n          backStack.push(this.tag(i));\n        }\n        if ((ref1 = this.tag(i), indexOf.call(EXPRESSION_START, ref1) >= 0) && backStack.length) {\n          backStack.pop();\n        }\n        i -= 1;\n      }\n      return ref5 = this.tag(i), indexOf.call(tags, ref5) >= 0;\n    };\n\n    Rewriter.prototype.addImplicitBracesAndParens = function() {\n      var stack, start;\n      stack = [];\n      start = null;\n      return this.scanTokens(function(token, i, tokens) {\n        var endImplicitCall, endImplicitObject, forward, inImplicit, inImplicitCall, inImplicitControl, inImplicitObject, isImplicit, isImplicitCall, isImplicitObject, k, newLine, nextTag, offset, prevTag, prevToken, ref, ref1, ref2, ref3, ref4, ref5, s, sameLine, stackIdx, stackItem, stackTag, stackTop, startIdx, startImplicitCall, startImplicitObject, startsLine, tag;\n        tag = token[0];\n        prevTag = (prevToken = i > 0 ? tokens[i - 1] : [])[0];\n        nextTag = (i < tokens.length - 1 ? tokens[i + 1] : [])[0];\n        stackTop = function() {\n          return stack[stack.length - 1];\n        };\n        startIdx = i;\n        forward = function(n) {\n          return i - startIdx + n;\n        };\n        isImplicit = function(stackItem) {\n          var ref;\n          return stackItem != null ? (ref = stackItem[2]) != null ? ref.ours : void 0 : void 0;\n        };\n        isImplicitObject = function(stackItem) {\n          return isImplicit(stackItem) && (stackItem != null ? stackItem[0] : void 0) === '{';\n        };\n        isImplicitCall = function(stackItem) {\n          return isImplicit(stackItem) && (stackItem != null ? stackItem[0] : void 0) === '(';\n        };\n        inImplicit = function() {\n          return isImplicit(stackTop());\n        };\n        inImplicitCall = function() {\n          return isImplicitCall(stackTop());\n        };\n        inImplicitObject = function() {\n          return isImplicitObject(stackTop());\n        };\n        inImplicitControl = function() {\n          var ref;\n          return inImplicit && ((ref = stackTop()) != null ? ref[0] : void 0) === 'CONTROL';\n        };\n        startImplicitCall = function(j) {\n          var idx;\n          idx = j != null ? j : i;\n          stack.push([\n            '(', idx, {\n              ours: true\n            }\n          ]);\n          tokens.splice(idx, 0, generate('CALL_START', '(', ['', 'implicit function call', token[2]]));\n          if (j == null) {\n            return i += 1;\n          }\n        };\n        endImplicitCall = function() {\n          stack.pop();\n          tokens.splice(i, 0, generate('CALL_END', ')', ['', 'end of input', token[2]]));\n          return i += 1;\n        };\n        startImplicitObject = function(j, startsLine) {\n          var idx, val;\n          if (startsLine == null) {\n            startsLine = true;\n          }\n          idx = j != null ? j : i;\n          stack.push([\n            '{', idx, {\n              sameLine: true,\n              startsLine: startsLine,\n              ours: true\n            }\n          ]);\n          val = new String('{');\n          val.generated = true;\n          tokens.splice(idx, 0, generate('{', val, token));\n          if (j == null) {\n            return i += 1;\n          }\n        };\n        endImplicitObject = function(j) {\n          j = j != null ? j : i;\n          stack.pop();\n          tokens.splice(j, 0, generate('}', '}', token));\n          return i += 1;\n        };\n        if (inImplicitCall() && (tag === 'IF' || tag === 'TRY' || tag === 'FINALLY' || tag === 'CATCH' || tag === 'CLASS' || tag === 'SWITCH')) {\n          stack.push([\n            'CONTROL', i, {\n              ours: true\n            }\n          ]);\n          return forward(1);\n        }\n        if (tag === 'INDENT' && inImplicit()) {\n          if (prevTag !== '=>' && prevTag !== '->' && prevTag !== '[' && prevTag !== '(' && prevTag !== ',' && prevTag !== '{' && prevTag !== 'TRY' && prevTag !== 'ELSE' && prevTag !== '=') {\n            while (inImplicitCall()) {\n              endImplicitCall();\n            }\n          }\n          if (inImplicitControl()) {\n            stack.pop();\n          }\n          stack.push([tag, i]);\n          return forward(1);\n        }\n        if (indexOf.call(EXPRESSION_START, tag) >= 0) {\n          stack.push([tag, i]);\n          return forward(1);\n        }\n        if (indexOf.call(EXPRESSION_END, tag) >= 0) {\n          while (inImplicit()) {\n            if (inImplicitCall()) {\n              endImplicitCall();\n            } else if (inImplicitObject()) {\n              endImplicitObject();\n            } else {\n              stack.pop();\n            }\n          }\n          start = stack.pop();\n        }\n        if ((indexOf.call(IMPLICIT_FUNC, tag) >= 0 && token.spaced || tag === '?' && i > 0 && !tokens[i - 1].spaced) && (indexOf.call(IMPLICIT_CALL, nextTag) >= 0 || indexOf.call(IMPLICIT_UNSPACED_CALL, nextTag) >= 0 && !((ref = tokens[i + 1]) != null ? ref.spaced : void 0) && !((ref1 = tokens[i + 1]) != null ? ref1.newLine : void 0))) {\n          if (tag === '?') {\n            tag = token[0] = 'FUNC_EXIST';\n          }\n          startImplicitCall(i + 1);\n          return forward(2);\n        }\n        if (indexOf.call(IMPLICIT_FUNC, tag) >= 0 && this.indexOfTag(i + 1, 'INDENT') > -1 && this.looksObjectish(i + 2) && !this.findTagsBackwards(i, ['CLASS', 'EXTENDS', 'IF', 'CATCH', 'SWITCH', 'LEADING_WHEN', 'FOR', 'WHILE', 'UNTIL'])) {\n          startImplicitCall(i + 1);\n          stack.push(['INDENT', i + 2]);\n          return forward(3);\n        }\n        if (tag === ':') {\n          s = (function() {\n            var ref2;\n            switch (false) {\n              case ref2 = this.tag(i - 1), indexOf.call(EXPRESSION_END, ref2) < 0:\n                return start[1];\n              case this.tag(i - 2) !== '@':\n                return i - 2;\n              default:\n                return i - 1;\n            }\n          }).call(this);\n          while (this.tag(s - 2) === 'HERECOMMENT') {\n            s -= 2;\n          }\n          this.insideForDeclaration = nextTag === 'FOR';\n          startsLine = s === 0 || (ref2 = this.tag(s - 1), indexOf.call(LINEBREAKS, ref2) >= 0) || tokens[s - 1].newLine;\n          if (stackTop()) {\n            ref3 = stackTop(), stackTag = ref3[0], stackIdx = ref3[1];\n            if ((stackTag === '{' || stackTag === 'INDENT' && this.tag(stackIdx - 1) === '{') && (startsLine || this.tag(s - 1) === ',' || this.tag(s - 1) === '{')) {\n              return forward(1);\n            }\n          }\n          startImplicitObject(s, !!startsLine);\n          return forward(2);\n        }\n        if (indexOf.call(LINEBREAKS, tag) >= 0) {\n          for (k = stack.length - 1; k >= 0; k += -1) {\n            stackItem = stack[k];\n            if (!isImplicit(stackItem)) {\n              break;\n            }\n            if (isImplicitObject(stackItem)) {\n              stackItem[2].sameLine = false;\n            }\n          }\n        }\n        newLine = prevTag === 'OUTDENT' || prevToken.newLine;\n        if (indexOf.call(IMPLICIT_END, tag) >= 0 || indexOf.call(CALL_CLOSERS, tag) >= 0 && newLine) {\n          while (inImplicit()) {\n            ref4 = stackTop(), stackTag = ref4[0], stackIdx = ref4[1], (ref5 = ref4[2], sameLine = ref5.sameLine, startsLine = ref5.startsLine);\n            if (inImplicitCall() && prevTag !== ',') {\n              endImplicitCall();\n            } else if (inImplicitObject() && !this.insideForDeclaration && sameLine && tag !== 'TERMINATOR' && prevTag !== ':') {\n              endImplicitObject();\n            } else if (inImplicitObject() && tag === 'TERMINATOR' && prevTag !== ',' && !(startsLine && this.looksObjectish(i + 1))) {\n              if (nextTag === 'HERECOMMENT') {\n                return forward(1);\n              }\n              endImplicitObject();\n            } else {\n              break;\n            }\n          }\n        }\n        if (tag === ',' && !this.looksObjectish(i + 1) && inImplicitObject() && !this.insideForDeclaration && (nextTag !== 'TERMINATOR' || !this.looksObjectish(i + 2))) {\n          offset = nextTag === 'OUTDENT' ? 1 : 0;\n          while (inImplicitObject()) {\n            endImplicitObject(i + offset);\n          }\n        }\n        return forward(1);\n      });\n    };\n\n    Rewriter.prototype.addLocationDataToGeneratedTokens = function() {\n      return this.scanTokens(function(token, i, tokens) {\n        var column, line, nextLocation, prevLocation, ref, ref1;\n        if (token[2]) {\n          return 1;\n        }\n        if (!(token.generated || token.explicit)) {\n          return 1;\n        }\n        if (token[0] === '{' && (nextLocation = (ref = tokens[i + 1]) != null ? ref[2] : void 0)) {\n          line = nextLocation.first_line, column = nextLocation.first_column;\n        } else if (prevLocation = (ref1 = tokens[i - 1]) != null ? ref1[2] : void 0) {\n          line = prevLocation.last_line, column = prevLocation.last_column;\n        } else {\n          line = column = 0;\n        }\n        token[2] = {\n          first_line: line,\n          first_column: column,\n          last_line: line,\n          last_column: column\n        };\n        return 1;\n      });\n    };\n\n    Rewriter.prototype.fixOutdentLocationData = function() {\n      return this.scanTokens(function(token, i, tokens) {\n        var prevLocationData;\n        if (!(token[0] === 'OUTDENT' || (token.generated && token[0] === 'CALL_END') || (token.generated && token[0] === '}'))) {\n          return 1;\n        }\n        prevLocationData = tokens[i - 1][2];\n        token[2] = {\n          first_line: prevLocationData.last_line,\n          first_column: prevLocationData.last_column,\n          last_line: prevLocationData.last_line,\n          last_column: prevLocationData.last_column\n        };\n        return 1;\n      });\n    };\n\n    Rewriter.prototype.normalizeLines = function() {\n      var action, condition, indent, outdent, starter;\n      starter = indent = outdent = null;\n      condition = function(token, i) {\n        var ref, ref1, ref2, ref3;\n        return token[1] !== ';' && (ref = token[0], indexOf.call(SINGLE_CLOSERS, ref) >= 0) && !(token[0] === 'TERMINATOR' && (ref1 = this.tag(i + 1), indexOf.call(EXPRESSION_CLOSE, ref1) >= 0)) && !(token[0] === 'ELSE' && starter !== 'THEN') && !(((ref2 = token[0]) === 'CATCH' || ref2 === 'FINALLY') && (starter === '->' || starter === '=>')) || (ref3 = token[0], indexOf.call(CALL_CLOSERS, ref3) >= 0) && (this.tokens[i - 1].newLine || this.tokens[i - 1][0] === 'OUTDENT');\n      };\n      action = function(token, i) {\n        return this.tokens.splice((this.tag(i - 1) === ',' ? i - 1 : i), 0, outdent);\n      };\n      return this.scanTokens(function(token, i, tokens) {\n        var j, k, ref, ref1, ref2, tag;\n        tag = token[0];\n        if (tag === 'TERMINATOR') {\n          if (this.tag(i + 1) === 'ELSE' && this.tag(i - 1) !== 'OUTDENT') {\n            tokens.splice.apply(tokens, [i, 1].concat(slice.call(this.indentation())));\n            return 1;\n          }\n          if (ref = this.tag(i + 1), indexOf.call(EXPRESSION_CLOSE, ref) >= 0) {\n            tokens.splice(i, 1);\n            return 0;\n          }\n        }\n        if (tag === 'CATCH') {\n          for (j = k = 1; k <= 2; j = ++k) {\n            if (!((ref1 = this.tag(i + j)) === 'OUTDENT' || ref1 === 'TERMINATOR' || ref1 === 'FINALLY')) {\n              continue;\n            }\n            tokens.splice.apply(tokens, [i + j, 0].concat(slice.call(this.indentation())));\n            return 2 + j;\n          }\n        }\n        if (indexOf.call(SINGLE_LINERS, tag) >= 0 && this.tag(i + 1) !== 'INDENT' && !(tag === 'ELSE' && this.tag(i + 1) === 'IF')) {\n          starter = tag;\n          ref2 = this.indentation(tokens[i]), indent = ref2[0], outdent = ref2[1];\n          if (starter === 'THEN') {\n            indent.fromThen = true;\n          }\n          tokens.splice(i + 1, 0, indent);\n          this.detectEnd(i + 2, condition, action);\n          if (tag === 'THEN') {\n            tokens.splice(i, 1);\n          }\n          return 1;\n        }\n        return 1;\n      });\n    };\n\n    Rewriter.prototype.tagPostfixConditionals = function() {\n      var action, condition, original;\n      original = null;\n      condition = function(token, i) {\n        var prevTag, tag;\n        tag = token[0];\n        prevTag = this.tokens[i - 1][0];\n        return tag === 'TERMINATOR' || (tag === 'INDENT' && indexOf.call(SINGLE_LINERS, prevTag) < 0);\n      };\n      action = function(token, i) {\n        if (token[0] !== 'INDENT' || (token.generated && !token.fromThen)) {\n          return original[0] = 'POST_' + original[0];\n        }\n      };\n      return this.scanTokens(function(token, i) {\n        if (token[0] !== 'IF') {\n          return 1;\n        }\n        original = token;\n        this.detectEnd(i + 1, condition, action);\n        return 1;\n      });\n    };\n\n    Rewriter.prototype.indentation = function(origin) {\n      var indent, outdent;\n      indent = ['INDENT', 2];\n      outdent = ['OUTDENT', 2];\n      if (origin) {\n        indent.generated = outdent.generated = true;\n        indent.origin = outdent.origin = origin;\n      } else {\n        indent.explicit = outdent.explicit = true;\n      }\n      return [indent, outdent];\n    };\n\n    Rewriter.prototype.generate = generate;\n\n    Rewriter.prototype.tag = function(i) {\n      var ref;\n      return (ref = this.tokens[i]) != null ? ref[0] : void 0;\n    };\n\n    return Rewriter;\n\n  })();\n\n  BALANCED_PAIRS = [['(', ')'], ['[', ']'], ['{', '}'], ['INDENT', 'OUTDENT'], ['CALL_START', 'CALL_END'], ['PARAM_START', 'PARAM_END'], ['INDEX_START', 'INDEX_END'], ['STRING_START', 'STRING_END'], ['REGEX_START', 'REGEX_END']];\n\n  exports.INVERSES = INVERSES = {};\n\n  EXPRESSION_START = [];\n\n  EXPRESSION_END = [];\n\n  for (k = 0, len = BALANCED_PAIRS.length; k < len; k++) {\n    ref = BALANCED_PAIRS[k], left = ref[0], rite = ref[1];\n    EXPRESSION_START.push(INVERSES[rite] = left);\n    EXPRESSION_END.push(INVERSES[left] = rite);\n  }\n\n  EXPRESSION_CLOSE = ['CATCH', 'THEN', 'ELSE', 'FINALLY'].concat(EXPRESSION_END);\n\n  IMPLICIT_FUNC = ['IDENTIFIER', 'PROPERTY', 'SUPER', ')', 'CALL_END', ']', 'INDEX_END', '@', 'THIS'];\n\n  IMPLICIT_CALL = ['IDENTIFIER', 'PROPERTY', 'NUMBER', 'INFINITY', 'NAN', 'STRING', 'STRING_START', 'REGEX', 'REGEX_START', 'JS', 'NEW', 'PARAM_START', 'CLASS', 'IF', 'TRY', 'SWITCH', 'THIS', 'UNDEFINED', 'NULL', 'BOOL', 'UNARY', 'YIELD', 'UNARY_MATH', 'SUPER', 'THROW', '@', '->', '=>', '[', '(', '{', '--', '++'];\n\n  IMPLICIT_UNSPACED_CALL = ['+', '-'];\n\n  IMPLICIT_END = ['POST_IF', 'FOR', 'WHILE', 'UNTIL', 'WHEN', 'BY', 'LOOP', 'TERMINATOR'];\n\n  SINGLE_LINERS = ['ELSE', '->', '=>', 'TRY', 'FINALLY', 'THEN'];\n\n  SINGLE_CLOSERS = ['TERMINATOR', 'CATCH', 'FINALLY', 'ELSE', 'OUTDENT', 'LEADING_WHEN'];\n\n  LINEBREAKS = ['TERMINATOR', 'INDENT', 'OUTDENT'];\n\n  CALL_CLOSERS = ['.', '?.', '::', '?::'];\n\n}).call(this);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}